<!DOCTYPE html>
<html>
<head>
  <title>Emojityper</title>
  <meta name="viewport" content="width=device-width, user-scalable=no" />
  <link href="https://fonts.googleapis.com/css?family=Lato:400,700|Lobster" rel="stylesheet" />
  <link href="styles.css" rel="stylesheet" />
  <link rel="search" type="application/opensearchdescription+xml" href="/opensearch.xml" title="Emojityper" />
  <script async src="https://cdn.rawgit.com/samthor/rippleJS/v1.0.2/ripple.min.js"></script>
  <script src="provider.js"></script>
  <script src="modifier.js"></script>
</head>
<body>

<header>
  <h1>Emojityper</h1>
  <div class="grow"></div>
  <div id="buttons" class="buttons ui">
    <button disabled id="copy" tabindex="-1" data-copied="Copied!">Copy</button>
  </div>
</header>

<main>
  <div id="input">
    <input type="text" id="typer" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" placeholder="Type words, receive emoji &#x1f44d;" autofocus />
    <div class="focus"></div>
  </div>
  <script>
/* nb. intentionally runs inline and is ES5 */
window.addEventListener('hashchange', function(ev) {
  var v = window.decodeURI(window.location.hash.substr(1));
  typer.value = v;
});
window.dispatchEvent(new CustomEvent('hashchange'));
  </script>
</main>
<div class="chooser" id="chooser"></div>

<div class="grow"></div>

<section class="advanced" id="advanced" hidden>
  <form>
    <input class="small" type="text" data-sequence="Give these emojis a name &#x270f;&#xfe0f;" placeholder="&#x270f;&#xfe0f; Name this emoji" pattern="[\w\d]+" />
    <div class="buttons ui">
      <button disabled>
        <div class="statusicon"></div>
        <div class="loader"></div>
        <div class="text">Submit</div>
      </button>
    </div>
  </form>
</section>

<footer>
  <ul class="help">
    <li><em>space</em> to get the default emoji</li>
    <li><em>enter</em> to copy to clipboard</li>
    <li><em>&larr;&uarr;&darr;&rarr;</em> to navigate options</li>
  </ul>
  <p>
    We <a href="https://github.com/emojityper/emojityper.github.io" target="_blank">made this</a> because you millennials really need your emoji. You can talk to us about it if you want:
    <span class="ib">
      <a target="_blank" href="https://twitter.com/mangopdf">@mangopdf</a>
      <a target="_blank" href="https://twitter.com/samthor">@samthor</a>
    </span>
  </p>
</footer>

<script>
// IE polyfills
(function() {
  if (typeof window.CustomEvent !== 'function') {
    function CustomEvent(name, params) {
      params = params || {bubbles: false, cancelable: false, detail: undefined};
      const event = document.createEvent('CustomEvent');
      event.initCustomEvent(name, params.bubbles, params.cancelable, params.detail);
      return event;
    }
    CustomEvent.prototype = window.Event.prototype;
    window.CustomEvent = CustomEvent;
  }

  if (!String.prototype.startsWith) {
    String.prototype.startsWith = function(search, from) {
      return this.substr(from || 0, search.length) === search;
    };
  }
})();

// suggestion handler
(function(input, chooser) {
  const modifiersEl = {};
  Array.from(chooser.querySelectorAll('.options.modifier')).forEach(el => modifiersEl[el.id] = el);

  // nb. this puncutation list is just misc stuff needed by emojimap
  const invalidLetterRe = /[^\w:\.,$%^\-']+/g;
  const simplifyWord = word => {
    if (word) {
      return word.replace(invalidLetterRe, '').toLowerCase();
    }
    return null;
  };

  let buttonArray = [];

  // button click handler
  chooser.addEventListener('click', ev => {
    const b = ev.target;
    if (b.localName !== 'button') {
      // ignore
    } else if (b.dataset['modifier']) {
      const value = 'value' in b.dataset ? (+b.dataset['value'] || b.dataset['value']) : null;
      const detail = {type: b.dataset['modifier'], code: value};
      input.dispatchEvent(new CustomEvent('modifier', {detail}));
    } else {
      const detail = {choice: b.textContent, word: b.dataset['word']};
      input.dispatchEvent(new CustomEvent('emoji', {detail}));
    }
  });

  // handle moving down from input
  input.addEventListener('keydown', ev => {
    if (ev.key === 'ArrowDown') {
      const first = chooser.querySelector('button');
      first && first.focus();
    }
  });

  // handle keyboard navigation inside chooser
  chooser.addEventListener('keydown', ev => {
    switch (ev.key) {
    case 'Escape':
      input.focus();
      break;
    }
    if (!ev.key.startsWith('Arrow')) { return; }

    const index = buttonArray.indexOf(document.activeElement);
    if (index === -1) { return; }

    // handle l/r keys
    let delta;
    if (ev.key === 'ArrowLeft') {
      delta = -1;
    } else if (ev.key === 'ArrowRight') {
      delta = +1;
    }
    if (delta) {
      const target = index + delta;
      if (target >= 0 && target < buttonArray.length) {
        buttonArray[target].focus();
      }
      return;  // done
    }

    // handle u/d keys
    if (ev.key === 'ArrowUp') {
      delta = -1;
    } else if (ev.key === 'ArrowDown') {
      delta = +1;
    } else {
      return;
    }
    const previousRect = document.activeElement.getBoundingClientRect();
    const best = {dist: Infinity, button: null};

    let targetTop = undefined;
    let candidate = index;
    while ((candidate += delta) >= 0 && candidate < buttonArray.length) {
      const button = buttonArray[candidate];
      const candidateRect = button.getBoundingClientRect();

      if (previousRect.top === candidateRect.top) { continue; }
      if (targetTop === undefined) {
        targetTop = candidateRect.top;
      }
      if (candidateRect.top !== targetTop) {
        break;  // no more good candidates
      }

      const dist = Math.abs(candidateRect.left - previousRect.left);
      if (dist < best.dist) {
        [best.dist, best.button] = [dist, button];
      }
    }
    if (best.button) {
      best.button.focus();
      return;
    }

    // if we were at top and going -ve, then return to input
    if (targetTop === undefined && delta < 0) {
      input.focus();
      return;
    }

  });

  let savedResults = null;
  let query = null;
  const show = results => {
    chooser.textContent = '';
    buttonArray.length = 0;
    savedResults = results;

    const createOptionsButtons = (heading, opt_class) => {
      const el = document.createElement('div');
      el.className = 'options';
      opt_class && el.classList.add(opt_class);

      const h4 = document.createElement('h4');
      h4.textContent = heading;
      el.appendChild(h4);

      const buttons = document.createElement('div');
      buttons.className = 'buttons';
      el.appendChild(buttons);
      chooser.appendChild(el);
      return buttons;
    };

    const createButton = (holder, content) => {
      const button = document.createElement('button');
      button.textContent = content;
      holder.appendChild(button);
      buttonArray.push(button);
      return button;
    };

    // if there's a focus but it's not a prefix (which implies that it's text-only)
    if (query.focus && !query.prefix) {
      const modifiers = {};
      const createModifierButton = (type, text, opt_value) => {
        let buttons = modifiers[type];
        if (!buttons) {
          modifiers[type] = buttons = createOptionsButtons(type, 'modifier');
        }
        const button = createButton(buttons, text);
        button.dataset['modifier'] = type;
        if (opt_value) {
          button.dataset['value'] = opt_value;
        }
      };

      const out = modifier.modify(query.focus);

      out.gender.neutral && createModifierButton('gender', '\u{2014}');
      out.gender.single && createModifierButton('gender', '\u{2640}', 'f');
      out.gender.double && createModifierButton('gender', '\u{2640}\u{2642}', 'fm');
      out.gender.single && createModifierButton('gender', '\u{2642}', 'm');
      out.gender.double && createModifierButton('gender', '\u{2642}\u{2640}', 'mf');

      if (out.diversity) {
        createModifierButton('diversity', '\u{2014}');
        for (let i = 0x1f3fb; i <= 0x1f3ff; ++i) {
          createModifierButton('diversity', String.fromCodePoint(i), i);
        }
      }
    }

    // FIXME: slowly add these (over frames), to amortize rendering hit
    // FIXME: we still get duplicates- some which are just force emoji / missing
    (results || []).forEach(result => {
      const name = result['name'];
      let buttons = null;
      result['options'].forEach(option => {
        // TODO: If a user has allowed it, render all emojis (even invalid) anyway.
        if (!isExpectedLength(option)) {
          // FIXME: are we discarding some for some reason?
          console.info('can\'t render', option, name);
          return;
        }
        if (!buttons) {
          // create if we haven't already got it
          buttons = createOptionsButtons(name);
        }
        const button = createButton(buttons, option);
        button.dataset['word'] = name;
      });
    });

    // set global class to indicate chooser visible
    document.body.classList.toggle('has-chooser', buttonArray.length > 0);
  };

  // set global callback for show
  window.emojimanager.callback = show;

  // handler for a prefix search
  input.addEventListener('query', ev => {
    query = ev.detail;
    window.emojimanager.request(query.text, query.prefix);
  });

  // request an autocomplete, the user has just kept typing
  input.addEventListener('request', ev => {
    const word = simplifyWord(ev.detail);
    let choice = null;

    (savedResults || []).some(result => {
      if (result.name !== word) { return false; }
      choice = result.options[0];
      return true;
    });

    if (choice) {
      const detail = {choice, word};
      input.dispatchEvent(new CustomEvent('emoji', {detail}));
    }
  });
}(typer, chooser));

// buttons handler
(function(holder, input) {
  const buttons = Array.prototype.slice.call(holder.querySelectorAll('button'));

  const handler = ev => {
    const text = (ev ? ev.detail : input.value).trim();
    const hasValue = Boolean(text);
    document.body.classList.toggle('has-value', hasValue);
    buttons.forEach(button => button.disabled = !hasValue);
  };

  input.addEventListener('value', handler);
  handler();

}(buttons, typer));

// hash handler
(function(input) {
  input.addEventListener('value', ev => {
    const v = ev.detail;
    window.history.replaceState(null, null, v ? ('#' + v) : window.location.pathname);
  });
}(typer));

// advanced handler
(function(input, advanced) {
  const form = advanced.querySelector('form');
  const namer = form.querySelector('input');
  const button = form.querySelector('button');

  let focus = '';

  input.addEventListener('query', ev => {
    const query = ev.detail;
    const selection = (query.text === null && query.focus !== undefined);
    focus = query.focus;
    advanced.hidden = !selection;
    if (advanced.hidden) {
      namer.value = '';
    }
  });

  const handler = ev => {
    button.disabled = !namer.value;
  };
  'input change'.split(/\s+/).forEach(type => namer.addEventListener(type, handler));

  form.addEventListener('submit', ev => {
    ev.preventDefault();

    form.classList.add('pending');
    namer.disabled = true;
    button.disabled = true;

    const cleanup = _ => {
      form.classList.remove('pending');
      namer.disabled = false;
      button.disabled = false;
      namer.value = '';
    };

    const p = emojimanager.submit(namer.value, focus).then(_ => {
      button.classList.add('success');
      return false;
    }).catch(err => {
      button.classList.add('failure');
      console.warn('failed to submit emoji', err)
      return true;
    }).then(cleanup);

    p.then(_ => new Promise((resolve, reject) => window.setTimeout(resolve, 2000))).then(_ => {
      button.className = '';
    });
  });

}(typer, advanced));

// copy handler
(function(button, input) {
  let timeout;
  const defaultText = button.textContent;
  const spaceRe = /\s*/;

  const copy = _ => {
    const [start, end] = [input.selectionStart, input.selectionEnd];

    // find start/end of content (trim, but find positions)
    let left = 0;
    let right = input.value.length;
    if (input.selectionStart !== input.selectionEnd) {
      left = input.selectionStart;
      right = input.selectionEnd;
    }
    left += spaceRe.exec(input.value.substr(left))[0].length;
    right = left + input.value.substr(left, right - left).trim().length;
    if (right <= left) { return false; }

    input.focus();
    input.selectionStart = left;
    input.selectionEnd = right;

    let ok = false;
    try {
      ok = document.execCommand('copy');
    } catch(e) {
      console.warn('could not copy', e);
      ok = false;
    }
    // restore previous selection
    [input.selectionStart, input.selectionEnd] = [start, end];

    if (!ok) { return true; }
    console.info('copied', input.value.substr(left, right));

    // show message
    button.textContent = button.dataset.copied;
    window.clearTimeout(timeout);
    timeout = window.setTimeout(ev => {
      button.textContent = defaultText;
    }, 500);
  };

  input.addEventListener('keydown', ev => {
    if (ev.key == 'Enter') {
      button.click();
      input.focus();
    }
  });
  button.addEventListener('click', ev => {
    copy();
    button.focus();
  });
}(copy, typer));

// word focus handler
(function(el) {
  const isWordCode = code => {
    // FIXME: turns out matching non-emoji is hard
    // TODO: this RegExp _might_ work but it needs transpiling-
    // new RegExp(/(?:[\p{Letter}\p{Number}\p{Punctuation}](?!\u{fe0f}?\u{20e3}))+/u);
    return code < 5000 && code != 32;
  };

  const helper = document.createElement('div');
  helper.className = 'overflow-helper';
  el.parentNode.insertBefore(helper, el);

  const underline = document.createElement('div');
  underline.className = 'underline';
  helper.appendChild(underline);

  const sizer = document.createElement('div');
  sizer.className = 'sizer';
  helper.appendChild(sizer);

  // hide underline until load: the font used might not be ready, so it's probably out of whack
  if (document.readyState !== 'complete') {
    underline.classList.add('loading');
    window.addEventListener('load', ev => {
      renderLine();
      underline.classList.remove('loading');
    });
  }

  const renderLine = _ => {
    if (el.dataset.from === undefined) {
      underline.hidden = true;
      return false;
    }
    const [from, to] = [+el.dataset.from, +el.dataset.to];

    // otherwise, record and draw the line
    const indent = 15;  // FIXME: from CSS, to match `text-indent`
    sizer.textContent = el.value.substr(0, from);
    const left = (from ? sizer.getBoundingClientRect().width : indent);

    sizer.textContent = el.value.substr(from, to - from);
    const width = sizer.getBoundingClientRect().width - indent;

    underline.hidden = false;
    underline.style.left = left + 'px';
    underline.style.width = width + 'px';
    underline.style.transform = 'translateX(-' + el.scrollLeft + 'px)';
  };

  // force selection
  const setRange = (from, to) => {
    if (from >= to) {
      ['from', 'to', 'prefix', 'word', 'focus'].forEach(key => delete(el.dataset[key]));
      underline.hidden = true;
      return false;
    }
    [el.dataset.from, el.dataset.to] = [from, to];
    el.dataset['focus'] = el.value.substr(from, to - from);
    renderLine();
    return true;
  };

  // state/handler keep track of the current focus word (plus scroll position, if input is big)
  const initialLength = el.value.length;
  const state = {start: initialLength, end: initialLength, value: undefined};
  const changeHandler = permitNextChange => {
    if (permitNextChange !== false &&
        el.selectionStart === state.start &&
        el.selectionEnd === state.end &&
        el.value === state.value) {
      return true;  // already at this state
    }
    [state.start, state.end] = [el.selectionStart, el.selectionEnd];
    if (state.value !== el.value) {
      el.dispatchEvent(new CustomEvent('value', {detail: el.value}));
      state.value = el.value;
    }

    // range selection, magic
    if (state.start !== state.end) {
      delete(el.dataset['prefix']);
      delete(el.dataset['word']);

      setRange(state.start, state.end);

      underline.classList.add('range');
      el.classList.add('range');
      return false;
    }
    underline.classList.remove('range');
    el.classList.remove('range');

    // calculate from/to locally
    let from = state.start;
    let to = state.start;

    // are we at the end (only have spaces until end)?
    const isAtEnd = !el.value.substr(state.end).trim();
    const isNotWordAfter = isAtEnd || !isWordCode(el.value.charCodeAt(state.end));

    if (isNotWordAfter) {
      for (; to > 0; --to) {
        if (el.value.charCodeAt(to - 1) !== 32) {
          break;
        }
      }
      if (to < from) {
        from = to;
      }
    }

    // walk backwards while the previous character is a word
    for (; from > 0; --from) {
      if (!isWordCode(el.value.charCodeAt(from - 1))) {
        break;
      }
    }

    // walk forwards while the next char is not a space
    for (; to < el.value.length; ++to) {
      if (!isWordCode(el.value.charCodeAt(to))) {
        break;
      }
    }

    // if it's invalid, but there's not a word after, and we were permitted, ignore
    if (from >= to && isNotWordAfter && permitNextChange) { return; }
    if (setRange(from, to)) {
      // if the range was valid, update the prefix/focus but delete the word (in typing state)
      el.dataset['focus'] = el.dataset['prefix'] = el.value.substr(from, to - from);
      delete(el.dataset['word']);
    }
  };

  // runs change handler and emits the 'word' event as appropriate
  const mergedEventHandler = (events, permitNextChange) => {
    // if there was a focus event, don't let the browser take over: reset previous known good
    if (events.has('focus')) {
      // only if it wasn't a range selection (otherwise clicking back retains range, weird)
      if (state.start === state.end) {
        // TODO: this sets on initial load, even though it probably doesn't need to
        [el.selectionStart, el.selectionEnd] = [state.start, state.end];
      }
    }

    // run change handler: if true, nothing changed
    if (changeHandler(permitNextChange)) { return; }

    // send query: prefix or whole-word
    let text = el.dataset.prefix || el.dataset.word || null;
    const detail = {text, prefix: 'prefix' in el.dataset, focus: el.dataset.focus};
    el.dispatchEvent(new CustomEvent('query', {detail}));
  };

  // dedup listeners on a rAF
  let permitNextChange;  // FIXME: global-ish scope is ugly
  (function() {
    let frame;
    let events = new Set();  // records the events that occured to cause this
    const dedup = ev => {
      if (!frame) {
        permitNextChange = undefined;
        events.clear();
        frame = window.requestAnimationFrame(_ => {
          frame = null;
          mergedEventHandler(events, permitNextChange);
        });
      }
      ev && events.add(ev.type);
    };

    // lots of listeners for a million different change reasons
    const rest = 'change keydown keypress focus click mousedown select input';
    rest.split(/\s+/).forEach(event => el.addEventListener(event, dedup));
    dedup();

    el.addEventListener('mousemove', ev => {
      if (ev.which) {
        dedup();
      }
    })

  }());

  // on blur, after a backspace, Chrome moves the start/end selection: fix it
  el.addEventListener('blur', ev => {
    if (el.selectionStart !== state.start || el.selectionStart !== state.end) {
      [el.selectionStart, el.selectionEnd] = [state.start, state.end];
    }
  });

  // add a non-deduped keydown handler, to run before others and intercept space
  el.addEventListener('keydown', ev => {
    switch (ev.key) {
    case 'Escape':
      permitNextChange = false;  // force next change
      break;

    case ' ':
      if (el.dataset.prefix && el.selectionStart === +el.dataset.to) {
        el.dispatchEvent(new CustomEvent('request', {detail: el.dataset.prefix}));
      }

      // TODO: do this to prevent actually space being hit (as "Sam Prefers")
      //ev.preventDefault();
      break;
    }
  });

  // dedup re-rendering calls
  (function() {
    let frame;
    const dedupRenderLine = _ => {
      if (!frame) {
        frame = window.requestAnimationFrame(_ => {
          frame = null;
          renderLine();
        });
      }
    };
    window.addEventListener('resize', dedupRenderLine);
    el.addEventListener('wheel', dedupRenderLine, {passive: true});
  }());

  // replace helper
  const replaceFocus = call => {
    if (el.dataset.from === undefined || el.dataset.to === undefined) { return false; }

    const [from, to] = [+el.dataset.from, +el.dataset.to];
    const value = el.value.substr(from, to - from);
    let [start, end] = [typer.selectionStart, typer.selectionEnd];

    const update = call(value);
    if (update == null) { return false; }
    typer.value = typer.value.substr(0, from) + update + typer.value.substr(to);

    const drift = where => {
      if (where > to) {
        // after the update
        where = where - (to - from) + update.length;
      } else if (where > from) {
        // during the update
        where = from + update.length;
      } else {
        // do nothing, was before
      }
      return where;
    };

    typer.focus();
    typer.dispatchEvent(new CustomEvent('change'));  // nb. updates from/to (from won't change)
    // pretend we were like this all along
    [state.start, state.end] = [typer.selectionStart, typer.selectionEnd] = [drift(start), drift(end)];

    permitNextChange = true;
    setRange(from, from + update.length);
    return true;
  };

  // handle 'modifier' event: apply modifiers to the focus word, if any
  el.addEventListener('modifier', ev => {
    const arg = {[ev.detail.type]: ev.detail.code};
    replaceFocus(value => modifier.modify(value, arg).out || '');
  });

  // handle 'emoji' event: if there's a current focus word, then replace it with the new emoji \o/
  el.addEventListener('emoji', ev => {
    const emoji = ev.detail.choice;
    if (!replaceFocus(_ => emoji)) { return; }

    // if this was a prefix match, now it's a word match (the word masks the emoji)
    el.dataset['word'] = ev.detail.word || el.dataset['prefix'];
    delete(el.dataset['prefix']);
  });
}(typer));
</script>

</body>
</html>
