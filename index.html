<!DOCTYPE html>
<html>
<head>
  <title>Emojityper</title>
  <meta name="viewport" content="width=device-width, user-scalable=no" />
  <link href="https://fonts.googleapis.com/css?family=Lato:400,700|Lobster" rel="stylesheet" />
  <link href="styles.css" rel="stylesheet" />
  <script async src="https://cdn.rawgit.com/samthor/rippleJS/v1.0.2/ripple.min.js"></script>
  <script src="provider.js"></script>
</head>
<body>

<header>
  <h1>Emojityper</h1>
  <div class="grow"></div>
  <div id="buttons" class="buttons">
    <button disabled id="copy" tabindex="-1" data-copied="Copied!">Copy</button>
    <button disabled id="add" class="strong" tabindex="-1">&#xff0b;</button>
  </div>
</header>

<main>
  <div id="input">
    <input type="text" id="typer" autocomplete="off" placeholder="Type words, receive emoji &#x1f44d;" autofocus />
    <div class="focus"></div>
  </div>
</main>
<div id="chooser" class="chooser"></div>

<div class="grow"></div>

<footer>
  We <a href="https://github.com/emojityper/emojityper.github.io" target="_blank">made this</a> because you millennials really need your emoji. You can talk to us about it if you want:
  <span class="ib">
    <a target="_blank" href="https://twitter.com/_notlikethis">@_notlikethis</a>
    <a target="_blank" href="https://twitter.com/samthor">@samthor</a>
  </span>
</footer>

<script>
// IE polyfills
(function() {
  if (typeof window.CustomEvent !== 'function') {
    function CustomEvent(name, params) {
      params = params || {bubbles: false, cancelable: false, detail: undefined};
      const event = document.createEvent('CustomEvent');
      event.initCustomEvent(name, params.bubbles, params.cancelable, params.detail);
      return event;
    }
    CustomEvent.prototype = window.Event.prototype;
    window.CustomEvent = CustomEvent;
  }

  if (!String.prototype.startsWith) {
    String.prototype.startsWith = function(search, from) {
      return this.substr(from || 0, search.length) === search;
    };
  }
})();

// suggestion handler
(function(input, chooser) {
  // nb. this puncutation list is just misc stuff needed by emojimap
  const invalidLetterRe = /[^\w:\.,$%^\-']+/g;
  const simplifyWord = word => {
    if (word) {
      return word.replace(invalidLetterRe, '').toLowerCase();
    }
    return null;
  };

  let buttonArray = [];

  // FIXME: sometimes click won't fire
  chooser.addEventListener('click', ev => {
    if (ev.target.localName !== 'button') { return; }
    const detail = {choice: ev.target.textContent, word: ev.target.dataset.word};
    input.dispatchEvent(new CustomEvent('emoji', {detail}));
  });

  input.addEventListener('keydown', ev => {
    if (ev.key == 'ArrowDown') {
      const first = chooser.querySelector('button');
      first && first.focus();
    }
  });

  chooser.addEventListener('keydown', ev => {
    if (!ev.key.startsWith('Arrow')) { return; }

    const index = buttonArray.indexOf(document.activeElement);
    if (index === -1) { return; }

    // handle l/r keys
    let delta;
    if (ev.key === 'ArrowLeft') {
      delta = -1;
    } else if (ev.key === 'ArrowRight') {
      delta = +1;
    }
    if (delta) {
      const target = index + delta;
      if (target >= 0 && target < buttonArray.length) {
        buttonArray[target].focus();
      }
      return;  // done
    }

    // handle u/d keys
    if (ev.key === 'ArrowUp') {
      delta = -1;
    } else if (ev.key === 'ArrowDown') {
      delta = +1;
    } else {
      return;
    }
    const previousRect = document.activeElement.getBoundingClientRect();
    const best = {dist: Infinity, button: null};

    let targetTop = undefined;
    let candidate = index;
    while ((candidate += delta) >= 0 && candidate < buttonArray.length) {
      const button = buttonArray[candidate];
      const candidateRect = button.getBoundingClientRect();

      if (previousRect.top === candidateRect.top) { continue; }
      if (targetTop === undefined) {
        targetTop = candidateRect.top;
      }
      if (candidateRect.top !== targetTop) {
        break;  // no more good candidates
      }

      const dist = Math.abs(candidateRect.left - previousRect.left);
      if (dist < best.dist) {
        [best.dist, best.button] = [dist, button];
      }
    }
    if (best.button) {
      best.button.focus();
      return;
    }

    // if we were at top and going -ve, then focus input
    if (targetTop === undefined && delta < 0) {
      // save and restore start/end, focus clears input
      // TODO: we want to save/restore start/end, but this can trigger reselect of text/emoji
      input.focus();
      return;
    }

  });

  let savedResults = null;
  let isPrefix = undefined;
  const show = results => {
    chooser.textContent = '';
    buttonArray.length = 0;
    savedResults = results;

    (results || []).forEach(result => {
      if (!isPrefix && window.emojimanager.request !== result['name']) {
        return;
      }

      const options = document.createElement('div');
      options.className = 'options';
      chooser.appendChild(options);

      const heading = document.createElement('h4');
      heading.textContent = result['name'];
      options.appendChild(heading);

      const buttons = document.createElement('div');
      buttons.className = 'buttons';
      options.appendChild(buttons);

      result['options'].forEach(option => {
        const button = document.createElement('button');
        button.textContent = option;
        button.dataset.word = result['name'];
        buttons.appendChild(button);
        buttonArray.push(button);
      });
    });
  };

  // set global callback for show
  window.emojimanager.callback = show;

  // handler for a prefix search
  input.addEventListener('query', ev => {
    // FIXME: pass prefix request to backend
    isPrefix = ev.detail.prefix;
    window.emojimanager.request = simplifyWord(ev.detail.text);
  });

  // request an autocomplete, the user has just kept typing
  input.addEventListener('request', ev => {
    const word = simplifyWord(ev.detail);
    let choice = null;

    (savedResults || []).some(result => {
      if (result.name !== word) { return false; }
      choice = result.options[0];
      return true;
    });

    if (choice) {
      const detail = {choice, word};
      input.dispatchEvent(new CustomEvent('emoji', {detail}));
    }
  });

}(typer, chooser));

// buttons handler
(function(holder, input) {
  const buttons = Array.prototype.slice.call(holder.querySelectorAll('button'));

  const handler = ev => {
    const text = (ev ? ev.detail : input.value).trim();
    buttons.forEach(button => button.disabled = !text);
  };

  input.addEventListener('value', handler);
  handler();

}(buttons, typer));

// copy handler
(function(button, input) {
  let timeout;
  const defaultText = button.textContent;
  const spaceRe = /\s*/;

  const copy = _ => {
    const [start, end] = [input.selectionStart, input.selectionEnd];

    // find start/end of content (trim, but find positions)
    const left = spaceRe.exec(input.value)[0].length;
    const right = left + input.value.substr(left).trim().length;
    if (right <= left) { return false; }

    input.focus();
    input.selectionStart = left;
    input.selectionEnd = right;

    let ok = false;
    try {
      ok = document.execCommand('copy');
    } catch(e) {
      console.warn('could not copy', e);
      ok = false;
    }
    // restore previous selection
    [input.selectionStart, input.selectionEnd] = [start, end];

    if (!ok) { return true; }
    console.info('copied', input.value.substr(left, right));

    // show message
    button.textContent = button.dataset.copied;
    window.clearTimeout(timeout);
    timeout = window.setTimeout(ev => {
      button.textContent = defaultText;
    }, 500);
  };

  input.addEventListener('keydown', ev => {
    if (ev.key == 'Enter') {
      button.click();
      input.focus();
    }
  });
  button.addEventListener('click', ev => {
    copy();
    button.focus();
  });
}(copy, typer));

// word focus handler
(function(el) {
  const isWordCode = code => {
    // FIXME: turns out matching non-emoji is hard
    return code < 5000 && code != 32;
  };

  const helper = document.createElement('div');
  helper.className = 'overflow-helper';
  el.parentNode.insertBefore(helper, el);

  const underline = document.createElement('div');
  underline.className = 'underline';
  helper.appendChild(underline);

  const sizer = document.createElement('div');
  sizer.className = 'sizer';
  helper.appendChild(sizer);

  // re-render underline
  const renderLine = _ => {
    if (el.dataset.from === undefined) {
      underline.hidden = true;
      return false;
    }
    const [from, to] = [+el.dataset.from, +el.dataset.to];

    // otherwise, record and draw the line
    const indent = 15;  // FIXME: from CSS, to match `text-indent`
    sizer.textContent = el.value.substr(0, from);
    const left = (from ? sizer.getBoundingClientRect().width : indent);

    sizer.textContent = el.value.substr(from, to - from);
    const width = sizer.getBoundingClientRect().width - indent;

    underline.hidden = false;
    underline.style.left = left + 'px';
    underline.style.width = width + 'px';
    underline.style.transform = 'translateX(-' + el.scrollLeft + 'px)';
  };

  // force selection
  const setRange = (from, to) => {
    if (from >= to) {
      underline.hidden = true;
      delete(el.dataset['from']);
      delete(el.dataset['to']);
      delete(el.dataset['prefix']);
      delete(el.dataset['word']);
      return false;
    }
    [el.dataset.from, el.dataset.to] = [from, to];
    renderLine();
    return true;
  };

  // state/handler keep track of the current focus word (plus scroll position, if input is big)
  const state = {start: 0, end: 0, value: undefined};
  const changeHandler = permitNextChange => {
    if (el.selectionStart === state.start &&
        el.selectionEnd === state.end &&
        el.value === state.value) {
      return true;  // already at this state
    }
    [state.start, state.end] = [el.selectionStart, el.selectionEnd];
    if (state.value !== el.value) {
      el.dispatchEvent(new CustomEvent('value', {detail: el.value}));
      state.value = el.value;
    }

    // range selection, ignore
    if (state.start !== state.end) { return false; }

    // calculate from/to locally
    let from = state.start;
    let to = state.start;

    // are we at the end (only have spaces until end)?
    const isAtEnd = !el.value.substr(state.end).trim();
    const isNotWordAfter = isAtEnd || !isWordCode(el.value.charCodeAt(state.end));

    if (isNotWordAfter) {
      for (; to > 0; --to) {
        if (el.value.charCodeAt(to - 1) !== 32) {
          break;
        }
      }
      if (to < from) {
        from = to;
      }
    }

    // walk backwards while the previous character is a word
    for (; from > 0; --from) {
      if (!isWordCode(el.value.charCodeAt(from - 1))) {
        break;
      }
    }

    // walk forwards while the next char is not a space
    for (; to < el.value.length; ++to) {
      if (!isWordCode(el.value.charCodeAt(to))) {
        break;
      }
    }

    // if it's invalid, but there's not a word after, and we were permitted, ignore
    if (from >= to && isNotWordAfter && permitNextChange) { return; }
    if (setRange(from, to)) {
      // if the range was valid, update the word: this means only text words end up here
      el.dataset.prefix = el.value.substr(from, to - from);
    }
  };

  // runs change handler and emits the 'word' event as appropriate
  const mergedEventHandler = (events, permitNextChange) => {
    // if there was a focus event, don't let the browser take over: reset previous known good
    if (events.has('focus')) {
      [el.selectionStart, el.selectionEnd] = [state.start, state.end];
    }

    // run change handler: if true, nothing changed
    if (changeHandler(permitNextChange)) { return; }

    // send query: prefix or whole-word
    let text = el.dataset.prefix || el.dataset.word || null;
    const detail = {text, prefix: 'prefix' in el.dataset};
    el.dispatchEvent(new CustomEvent('query', {detail}));
  };

  // dedup listeners on a rAF
  let permitNextChange;  // FIXME: global-ish scope is ugly
  (function() {
    let frame;
    let events = new Set();  // records the events that occured to cause this
    const dedup = ev => {
      if (!frame) {
        permitNextChange = false;
        events.clear();
        frame = window.requestAnimationFrame(_ => {
          frame = null;
          mergedEventHandler(events, permitNextChange);
        });
      }
      ev && events.add(ev.type);
    };

    // lots of listeners for a million different change reasons
    const rest = 'change keydown keypress focus click mousedown';
    rest.split(/\s+/).forEach(event => el.addEventListener(event, dedup));
    dedup();
  }());

  // on blur, after a backspace, Chrome moves the start/end selection: fix it
  el.addEventListener('blur', ev => {
    if (el.selectionStart !== state.start || el.selectionStart !== state.end) {
      [el.selectionStart, el.selectionEnd] = [state.start, state.end];
    }
  });

  // add a non-deduped keydown handler, to run before others and intercept space
  el.addEventListener('keydown', ev => {
    switch (ev.key) {
    case 'Enter':
      el.dispatchEvent(new CustomEvent('send'));
      break;
    case ' ':
      if (el.dataset.prefix && el.selectionStart === +el.dataset.to) {
        el.dispatchEvent(new CustomEvent('request', {detail: el.dataset.prefix}));
      }

      // TODO: do this to prevent actually space being hit (as "Sam Prefers")
      //ev.preventDefault();
      break;
    }
  });

  // dedup re-rendering calls
  (function() {
    let frame;
    const dedupRenderLine = _ => {
      if (!frame) {
        frame = window.requestAnimationFrame(_ => {
          frame = null;
          renderLine();
        });
      }
    };
    window.addEventListener('resize', dedupRenderLine);
    el.addEventListener('wheel', dedupRenderLine, {passive: true});
  }());

  // handle 'emoji' event: if there's a current focus word, then replace it with the new emoji \o/
  el.addEventListener('emoji', ev => {
    if (el.dataset.from === undefined || el.dataset.to === undefined) { return; }

    const [from, to] = [+el.dataset.from, +el.dataset.to];
    let start = typer.selectionStart;

    const emoji = ev.detail.choice;
    typer.value = typer.value.substr(0, from) + emoji + typer.value.substr(to);

    if (start > to) {
      // after the emoji
      start = start - (to - from) + emoji.length;
    } else if (start > from) {
      // during the emoji
      start = from + emoji.length;
    } else {
      // do nothing, was before
    }
    typer.focus();
    typer.dispatchEvent(new CustomEvent('change'));
    typer.selectionStart = start;
    typer.selectionEnd = start;
    state.start = state.end = start;  // pretend we were like this all along

    // if this was a prefix match, now it's a word match (the word masks the emoji)
    el.dataset['word'] = ev.detail.word || el.dataset['prefix'];
    delete(el.dataset['prefix']);

    permitNextChange = true;
    setRange(from, from + emoji.length);
  });
}(typer));
</script>

</body>
</html>