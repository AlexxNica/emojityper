<!DOCTYPE html>
<html>
<head>
  <title>Emojityper</title>
  <meta name="viewport" content="width=device-width, user-scalable=no" />
  <link href="https://fonts.googleapis.com/css?family=Lato:400,700|Lobster" rel="stylesheet" />
  <link href="styles.css" rel="stylesheet" />
  <script async src="https://cdn.rawgit.com/samthor/rippleJS/v1.0.2/ripple.min.js"></script>
  <script src="provider.js"></script>
</head>
<body>

<h1>Emojityper</h1>

<main>
  <div id="input">
    <input type="text" id="typer" autocomplete="off" placeholder="Type words, receive emoji &#x1f44d;" autofocus />
    <div class="focus"></div>
  </div>
  <div id="buttons">
    <button id="copy" tabindex="-1" data-copied="Copied!">Copy</button>
  </div>
</main>
<div id="chooser" class="chooser"></div>

<div class="grow"></div>

<footer>
  We made this because you millennials really need your emoji. You can talk to us about it if you want:
  <span class="ib">
    <a target="_blank" href="https://twitter.com/_notlikethis">@_notlikethis</a>
    <a target="_blank" href="https://twitter.com/samthor">@samthor</a>
  </span>
</footer>

<script>
// IE9-11 CustomEvent polyfill
(function() {
  if (typeof window.CustomEvent === 'function') { return false };
  function CustomEvent(name, params) {
    params = params || {bubbles: false, cancelable: false, detail: undefined};
    const event = document.createEvent('CustomEvent');
    event.initCustomEvent(name, params.bubbles, params.cancelable, params.detail);
    return event;
  }
  CustomEvent.prototype = window.Event.prototype;
  window.CustomEvent = CustomEvent;
})();

// suggestion handler
(function() {
  const invalidLetterRe = /\W+/g;
  const simplifyWord = word => {
    if (word) {
      return word.replace(invalidLetterRe, '').toLowerCase();
    }
    return null;
  };

  // FIXME: sometimes click won't fire
  chooser.addEventListener('click', ev => {
    if (ev.target.localName !== 'button') { return; }
    typer.dispatchEvent(new CustomEvent('emoji', {detail: ev.target.textContent}));
  });

  let savedResults = null;

  const show = results => {
    chooser.textContent = '';
    savedResults = results;

    (results || []).forEach(result => {
      const options = document.createElement('div');
      options.className = 'options';
      chooser.appendChild(options);

      const heading = document.createElement('h4');
      heading.textContent = result['name'];
      options.appendChild(heading);

      result['options'].forEach(thing => {
        const option = document.createElement('button');
        option.textContent = thing;
        options.appendChild(option);
      });
    });
  };

  // set global callback for show
  window.emojimanager.callback = show;

  // handler for a word change
  typer.addEventListener('word', ev => {
    console.info('got new word', ev.detail);
    window.emojimanager.request = simplifyWord(ev.detail);
  });

  // request an autocomplete, the user has just kept typing
  typer.addEventListener('request', ev => {
    const word = simplifyWord(ev.detail);
    let choice = null;

    (savedResults || []).some(result => {
      if (result.name !== word) { return false; }
      choice = result.options[0];
      return true;
    });

    if (choice) {
      typer.dispatchEvent(new CustomEvent('emoji', {detail: choice}));
    }
  });

}());

// copy handler
(function(button, input) {
  let timeout;
  const defaultText = button.textContent;
  const spaceRe = /\s*/;

  const copy = _ => {
    const [start, end] = [input.selectionStart, input.selectionEnd];

    // find start/end of content (trim, but find positions)
    const left = spaceRe.exec(input.value)[0].length;
    const right = left + input.value.substr(left).trim().length;
    if (right <= left) { return false; }

    input.focus();
    input.selectionStart = left;
    input.selectionEnd = right;

    let ok = false;
    try {
      ok = document.execCommand('copy');
    } catch(e) {
      console.warn('could not copy', e);
      ok = false;
    }
    // restore previous selection
    [input.selectionStart, input.selectionEnd] = [start, end];

    if (!ok) { return true; }
    console.info('copied', input.value.substr(left, right));

    // show message
    button.textContent = button.dataset.copied;
    window.clearTimeout(timeout);
    timeout = window.setTimeout(ev => {
      button.textContent = defaultText;
    }, 500);
  };

  input.addEventListener('keydown', ev => {
    if (ev.key == 'Enter') {
      button.click();
    }
  });
  button.addEventListener('click', _ => copy());
}(copy, typer));

// word focus handler
(function(el) {
  const isWordCode = code => {
    // FIXME: turns out matching non-emoji is hard
    return code < 5000 && code != 32;
  };

  const helper = document.createElement('div');
  helper.className = 'overflow-helper';
  el.parentNode.insertBefore(helper, el);

  const underline = document.createElement('div');
  underline.className = 'underline';
  helper.appendChild(underline);

  const sizer = document.createElement('div');
  sizer.className = 'sizer';
  helper.appendChild(sizer);

  // re-render underline
  const renderLine = _ => {
    if (el.dataset.from === undefined) {
      underline.hidden = true;
      return false;
    }
    const [from, to] = [+el.dataset.from, +el.dataset.to];

    // otherwise, record and draw the line
    const indent = 15;  // FIXME: from CSS, to match `text-indent`
    sizer.textContent = el.value.substr(0, from);
    const left = (from ? sizer.getBoundingClientRect().width : indent);

    sizer.textContent = el.value.substr(from, to - from);
    const width = sizer.getBoundingClientRect().width - indent;

    underline.hidden = false;
    underline.style.left = left + 'px';
    underline.style.width = width + 'px';
    underline.style.transform = 'translateX(-' + el.scrollLeft + 'px)';
  };

  // force selection
  const setRange = (from, to) => {
    if (from >= to) {
      underline.hidden = true;
      delete(el.dataset['from']);
      delete(el.dataset['to']);
      delete(el.dataset['word']);
      return false;
    }
    [el.dataset.from, el.dataset.to] = [from, to];
    el.dataset.word = el.value.substr(from, to - from);
    renderLine();
  };

  // state/handler keep track of the current focus word (plus scroll position, if input is big)
  const state = {start: undefined, end: undefined, value: undefined};
  const changeHandler = permitNextChange => {
    if (el.selectionStart === state.start &&
        el.selectionEnd === state.end &&
        el.value === state.value) {
      return true;  // already at this state
    }
    [state.start, state.end] = [el.selectionStart, el.selectionEnd];
    state.value = el.value;

    // range selection, ignore
    if (state.start !== state.end) { return false; }

    // calculate from/to locally
    let from = state.start;
    let to = state.start;

    // are we at the end (only have spaces until end)?
    const isAtEnd = !el.value.substr(state.end).trim();
    const isNotWordAfter = isAtEnd || !isWordCode(el.value.charCodeAt(state.end));

    if (isNotWordAfter) {
      for (; to > 0; --to) {
        if (el.value.charCodeAt(to - 1) !== 32) {
          break;
        }
      }
      if (to < from) {
        from = to;
      }
    }

    // walk backwards while the previous character is a word
    for (; from > 0; --from) {
      if (!isWordCode(el.value.charCodeAt(from - 1))) {
        break;
      }
    }

    // walk forwards while the next char is not a space
    for (; to < el.value.length; ++to) {
      if (!isWordCode(el.value.charCodeAt(to))) {
        break;
      }
    }

    // if it's invalid, but there's not a word after, and we were permitted, ignore
    if (from >= to && isNotWordAfter && permitNextChange) { return; }
    return setRange(from, to);
  };

  // runs change handler and emits the 'word' event as appropriate
  let lastWord = undefined;
  const mergedEventHandler = permitNextChange => {
    if (changeHandler(permitNextChange)) { return; }

    let word = el.dataset.word || null;
    if (word === lastWord) { return; }
    lastWord = word;
    el.dispatchEvent(new CustomEvent('word', {detail: word}))
  };

  // dedup listeners on a rAF
  let permitNextChange;  // FIXME: global-ish scope is ugly
  (function() {
    let frame;
    const dedup = ev => {
      if (!frame) {
        permitNextChange = false;
        frame = window.requestAnimationFrame(_ => {
          frame = null;
          mergedEventHandler(permitNextChange);
        });
      }
    };

    // lots of listeners for a million different change reasons
    const rest = 'change keydown keypress focus click mousedown';
    rest.split(/\s+/).forEach(event => el.addEventListener(event, dedup));
    dedup();
  }());

  // add a non-deduped keydown handler, to run before others and intercept space
  el.addEventListener('keydown', ev => {
    switch (ev.key) {
    case 'Enter':
      el.dispatchEvent(new CustomEvent('send'));
      break;
    case ' ':
      if (el.dataset.to === undefined || el.selectionStart !== +el.dataset.to) { break; }

      // check that the focus word is all-text, not an emoji
      let valid = true;
      const word = el.dataset.word;
      for (let i = 0; i < word.length; ++i) {
        if (!isWordCode(word.charCodeAt(i))) {
          valid = false;
          break;
        }
      }
      if (valid) {
        el.dispatchEvent(new CustomEvent('request', {detail: word}));
      }

      // TODO: do this to prevent actually space being hit (as "Sam Prefers")
      //ev.preventDefault();
      break;
    }
  });

  // dedup re-rendering calls
  (function() {
    let frame;
    const dedupRenderLine = _ => {
      if (!frame) {
        frame = window.requestAnimationFrame(_ => {
          frame = null;
          renderLine();
        });
      }
    };
    window.addEventListener('resize', dedupRenderLine);
    el.addEventListener('wheel', dedupRenderLine, {passive: false});
  }());

  // handle 'emoji' event: if there's a current focus word, then replace it with the new emoji \o/
  el.addEventListener('emoji', ev => {
    const emoji = ev.detail;
    if (el.dataset.from === undefined || el.dataset.to === undefined) { return; }

    const [from, to] = [+el.dataset.from, +el.dataset.to];
    let start = typer.selectionStart;

    typer.value = typer.value.substr(0, from) + emoji + typer.value.substr(to);

    if (start > to) {
      start = start - (to - from) + emoji.length;
    } else if (start > from) {
      start = from + emoji.length;
    } else {
      // do nothing, was before
    }
    typer.focus();
    typer.dispatchEvent(new CustomEvent('change'));
    typer.selectionStart = start;
    typer.selectionEnd = start;

    permitNextChange = true;
    setRange(from, from + emoji.length);
  });
}(typer));
</script>

</body>
</html>