{"version":3,"sources":["src/support/check.js","src/support/polyfill.js","src/lib/modifier.js","src/lib/provider.js","src/buttons.js","src/input.js","src/options.js","src/selection.js"],"names":["window","location","search","indexOf","Map","CustomEvent","name","params","bubbles","cancelable","detail","undefined","event","document","createEvent","initCustomEvent","prototype","Event","String","startsWith","from","this","substr","length","Array","arg","slice","call","isPointGender","p","isPersonGender","isFamilyMember","isVariationSelector","isDiversitySelector","isFlagPoint","unlikelyModifierBase","jsdecode","s","len","points","i","raw","charCodeAt","extra","push","splitEmoji","curr","point","suffix","out","check","next","modify","opt_op","stats","diversity","gender","single","double","neutral","chars","record","some","char","first","genderable","family","forEach","ch","flip","genderFlip","isSinglePerson","basicDiversity","candidate","fromCodePoint","isSingle","nextGenderPoint","g","previousMaster","index","master","opt_point","opt_allowOtherFlip","n","m","f","map","allowOtherFlip","genderPoint","reduce","all","concat","request","text","prefix","requestAnimationFrame","submit","value","data","FormData","append","fetch","api","method","mode","callback","buttons","querySelectorAll","handler","ev","typer","trim","hasValue","Boolean","body","classList","toggle","button","disabled","addEventListener","input","timeout","defaultText","textContent","spaceRe","copy","selectionStart","selectionEnd","start","end","left","right","exec","focus","ok","execCommand","e","warn","info","dataset","copied","clearTimeout","setTimeout","key","click","measureText","context","createElement","getContext","font","cache","count","result","width","fixedWidthEmoji","emojiWidth","invalidWidth","isExpectedLength","flags","total","expectedLength","Math","ceil","floor","c","list","j","v","has","Error","set","get","el","isWordCode","code","helper","className","parentNode","insertBefore","underline","appendChild","sizer","readyState","add","remove","renderLine","hidden","to","getBoundingClientRect","getElementById","style","transform","scrollLeft","setRange","initialLength","state","changeHandler","permitNextChange","dispatchEvent","isNotWordAfter","mergedEventHandler","events","word","frame","Set","dedup","clear","type","split","which","dedupRenderLine","passive","replaceFocus","update","drift","where","modifier","emoji","choice","indexed","then","json","prefixSuggest","k","emojimap","part","opts","typed","rest","toLowerCase","filter","options","requestCallback","performRequest","send","localTimeout","results","suggest","chooser","invalidLetterRe","simplifyWord","replace","buttonArray","b","target","localName","querySelector","activeElement","delta","previousRect","best","dist","Infinity","targetTop","candidateRect","top","abs","savedResults","query","createOptionsButtons","heading","opt_class","h4","createButton","holder","content","modifiers","createModifierButton","opt_value","option","advanced","form","namer","selection","preventDefault","provider","catch","err","Promise","resolve","reject"],"mappings":"yBACKA,OAAOC,SAASC,SAA8D,IAApDF,OAAOC,SAASC,OAAOC,QAAQ,iBACpCH,OAAOI,aAEtBH,SAAW;;yBCCtB,GAAkC,mBAAvBD,OAAOK,YAA4B,KACnCA,EAAT,SAAqBC,EAAMC,KAChBA,IAAWC,SAAS,EAAOC,YAAY,EAAOC,YAAQC,OACzDC,EAAQC,SAASC,YAAY,wBAC7BC,gBAAgBT,EAAMC,EAAOC,QAASD,EAAOE,WAAYF,EAAOG,QAC/DE,KAEGI,UAAYhB,OAAOiB,MAAMD,iBAC9BX,YAAcA,EAGlBa,OAAOF,UAAUG,oBACbH,UAAUG,WAAa,SAASjB,EAAQkB,UACtCC,KAAKC,OAAOF,GAAQ,EAAGlB,EAAOqB,UAAYrB,IAIhDsB,MAAMJ,aACHA,KAAO,SAASK,UAEbD,MAAMR,UAAUU,MAAMC,KAAKF;;iJCmGtC,SAASG,EAAcC,UACR,OAANA,GAAsB,OAANA,EAOzB,SAASC,EAAeD,UACT,SAANA,GAAuB,SAANA,EAO1B,SAASE,EAAeF,UACT,SAANA,GAAuB,SAANA,GAAuB,SAANA,EAO3C,SAASG,EAAoBH,UACnBA,GAAK,OAAUA,GAAK,OAAYA,GAAK,QAAWA,GAAK,OAO/D,SAASI,EAAoBJ,UACpBA,GAAK,QAAWA,GAAK,OAO9B,SAASK,EAAYL,UACZA,GAAK,QAAWA,GAAK,OAO9B,SAASM,EAAqBN,UACrBA,EAAI,MAAUD,EAAcC,IAAMG,EAAoBH,IAAMI,EAAoBJ,IACnFK,EAAYL,GASlB,SAASO,EAASC,OAIX,IAHCC,EAAMD,EAAEd,OACRgB,KAEGC,EAAI,EAAGA,EAAIF,GAAM,KAClBG,EAAMJ,EAAEK,WAAWF,MAAQ,KAC7BC,EAAM,OAAUA,EAAM,OAAUD,IAAMF,OAEnC,KACCK,EAAQN,EAAEK,WAAWF,IAAM,KACR,QAAZ,MAARG,GAA4B,GAE7BH,IACKI,KAAK,OAAmB,KAARD,KAAyB,KAANF,IAAgB,iBAIvDG,KAAKH,UAGPF,EA4DT,SAASM,EAAWN,OACbA,EAAOhB,oBAWP,IARDuB,IAASC,MAAOR,EAAO,GAAIS,OAAQ,IACjCC,GAAOH,GAOJN,EAAI,EAAGA,EAAID,EAAOhB,SAAUiB,EAAG,KAChCU,EAAQX,EAAOC,MAEjBN,EAAYY,EAAKA,EAAKvB,OAAO,GAAGwB,YAE7B,CAAA,GAAId,EAAoBiB,IAAUlB,EAAoBkB,GAAQ,GAE9DJ,EAAKvB,OAAO,GAAGyB,OAASE,WAExB,GAAc,OAAVA,EAAkB,KAErBC,EAAOZ,IAASC,MACdM,EAAKF,MAAMG,MAAOI,EAAMH,OAAQ,kBAKjCD,MAAOG,EAAOF,OAAQ,MAC3BJ,KAAKE,UAEJG,EAYT,SAAgBG,EAAOf,EAAGgB,OAElBC,GAASC,WAAW,EAAOC,QAASC,QAAQ,EAAOC,QAAQ,EAAOC,SAAS,IAG3EC,EAAQf,EAJCT,EAASC,IAKlBwB,EAAUR,KAAc,UACxBS,KAAK,SAACC,EAAMvB,OACVwB,EAAQD,EAAK,GAAGhB,MAClBkB,EAAa,EACbC,GAAS,IAGRC,QAAQ,gBACLtC,EAAIuC,EAAGrB,SACTnB,EAAcC,KAEV2B,OAAOC,QAAS,IAChBD,OAAOG,SAAU,OAClB,GAAI7B,EAAeD,KAElB2B,OAAOC,QAAS,IAChBQ,GAAc,MACZT,OAAOE,QAAS,QAEnB,GAAI3B,EAAeF,IAAMoC,KAErB,MACJ,KAECI,EAAOC,EAAWzC,GACpBwC,MACIb,OAAOC,QAAUY,EAAKZ,SACtBD,OAAOG,SAAWU,EAAKV,gBAM7BY,EACFN,EAAcnC,EAAekC,IAAyB,IAAfC,IAAqBC,OAAUvD,KACtE4D,MACIhB,UAAYiB,GAEhBX,MAIKrB,GAAK+B,IAITjB,EAAMC,YAAciB,IAAmBlB,EAAME,OAAOG,eAE/CE,GAAUP,EAAME,OAAOC,QAAUH,EAAME,OAAOE,WAIjC,IAAnBa,IAA4BpC,EAAqB6B,QAI/CS,EAAYvD,OAAOwD,cAAcV,GACnCQ,IAAmBlB,EAAMC,WAAaoB,EAASF,EAAY,oBACvDlB,WAAY,IAEfD,EAAME,OAAOG,SAAWgB,EAASF,EAAY,0BAC1CjB,OAAOG,SAAU,IACjBH,OAAOC,QAAS,OAKrBJ,SACIC,MAIHsB,EAAmB,eACjBC,EAAIxB,EAAOG,QAAU,GACvBsB,SACAC,gBACG,SAACC,EAAQC,EAAWC,QACFvE,IAAnBmE,GAAgCE,IAAWF,KAC5BE,IACT,KAEND,MAEE5B,EAAO0B,EAAIA,EAAEE,EAAQF,EAAEtD,QAAU,GACjCwB,EAAQkC,GAAa,KACvBnD,EAAeiB,UAEVI,EAAiB,MAATA,EAAe,OAAU,OAAWJ,EAC9C,IAAKA,GAASnB,EAAcmB,UAE1BI,EAAiB,MAATA,EAAe,KAAS,KAAU,EAC5C,GAAI+B,EAAoB,KAEvBb,EAAOC,EAAWvB,MACpBsB,EAAM,KACHlB,GAAQkB,EAAKV,eACTU,EAAK9B,OAAO4C,EACd,GAAIhC,GAAQkB,EAAKZ,aACN,MAATN,EAAekB,EAAK9B,OAAO6C,EAAIf,EAAK9B,OAAO8C,WAKtDN,EACKhC,MAKLE,EAAMW,EAAM0B,IAAI,SAACvB,EAAMvB,OACrBD,KACAgC,EAAiBV,EAAOrB,GACxBwB,EAAQD,EAAK,GAAGhB,cAEApC,IAAlB0C,EAAOG,OAAsB,KAGzB+B,OAAqC5E,IAAnB4D,OACnBJ,QAAQ,mBAAMC,EAAGrB,MAAQ6B,EAAgBrC,EAAQ6B,EAAGrB,MAAOwC,UAGzC5E,IAAnB4D,GAAgD,IAAhBR,EAAKxC,SAAiBK,EAAcoC,GAAQ,KACxEwB,EAAcZ,EAAgBrC,GAChCiD,GAAeb,EAASzD,OAAOwD,cAAcV,GAAS,yBACnDpB,MAAMI,OAAQ,MAAQD,MAAOyC,iBAMf7E,IAArB0C,EAAOE,aACJY,QAAQ,SAACC,EAAI5B,GACZP,EAAoBmC,EAAGpB,UAEtBA,OAASK,EAAOE,UACJ,IAANf,GAAWgC,IAAqC,IAAnBD,IAElCA,GAAkBI,EAASzD,OAAOwD,cAAcV,GAAS,qBACxDhB,OAASK,EAAOE,eAOtBY,QAAQ,YACPC,EAAGrB,UACExB,QAAUgB,EAAOK,KAAK,QACtBA,KAAKwB,EAAGrB,SACZC,QAAUT,EAAOK,KAAKwB,EAAGpB,WAGzBT,IACNkD,OAAO,SAACC,EAAKnD,UAAWmD,EAAIC,OAAOpD,iBAEhCU,IAAM/B,OAAOwD,6BAAiBzB,IAC7BK,0HC5YT,SAAgBsC,EAAQC,EAAMC,UACrBC,sBAAsB,cACZF,EAAMC,KAIzB,SAAgBE,EAAO1F,EAAM2F,OAIrBC,EAAO,IAAIC,kBACZC,OAAO,OAAQ9F,KACf8F,OAAO,QAASH,GACdjG,OAAOqG,MAAMC,EAAM,SAAUC,OAAQ,OAAQL,OAAMM,KAAM,YAGlE,SAAgBC,EAASA,KACLA,ECzFpB,IAAMf,EAAMlE,MAAMR,UAAUU,MAAMC,KAAK+E,QAAQC,iBAAiB,WAE1DC,EAAU,gBACRf,GAAQgB,EAAKA,EAAGnG,OAASoG,MAAMb,OAAOc,OACtCC,EAAWC,QAAQpB,YAChBqB,KAAKC,UAAUC,OAAO,YAAaJ,KACxC7C,QAAQ,mBAAUkD,EAAOC,UAAYN,KAG3CF,MAAMS,iBAAiB,QAASX,GAChCA,IAGC,SAASS,EAAQG,OACZC,SACEC,EAAcL,EAAOM,YACrBC,EAAU,MAEVC,EAAO,mBACWL,EAAMM,eAAgBN,EAAMO,cAA3CC,OAAOC,OAGVC,EAAO,EACPC,EAAQX,EAAMvB,MAAM1E,UACpBiG,EAAMM,iBAAmBN,EAAMO,iBAC1BP,EAAMM,iBACLN,EAAMO,iBAERH,EAAQQ,KAAKZ,EAAMvB,MAAM3E,OAAO4G,IAAO,GAAG3G,UAC1C2G,EAAOV,EAAMvB,MAAM3E,OAAO4G,EAAMC,EAAQD,GAAMnB,OAAOxF,SAChD2G,SAAe,IAEtBG,UACAP,eAAiBI,IACjBH,aAAeI,MAEjBG,GAAK,QAEFzH,SAAS0H,YAAY,QAC1B,MAAMC,WACEC,KAAK,iBAAkBD,MAC1B,SAGuCR,EAAOC,QAA9CH,sBAAsBC,mBAExBO,SAAa,UACVI,KAAK,SAAUlB,EAAMvB,MAAM3E,OAAO4G,EAAMC,MAGzCR,YAAcN,EAAOsB,QAAQC,cAC7BC,aAAapB,KACVzH,OAAO8I,WAAW,cACnBnB,YAAcD,GACpB,QAGCH,iBAAiB,UAAW,YAClB,SAAVV,EAAGkC,QACEC,UACDX,aAGHd,iBAAiB,QAAS,kBAExBc,WAETR,KAAMf,OF/DR,IAAMmC,EAAe,eAEbC,EADSrI,SAASsI,cAAc,UACfC,WAAW,QAC1BC,KAAO,oBAEXC,KACAC,EAAQ,SAEL,gBACDC,EAASF,EAAMjH,eACJ1B,IAAX6I,MACInH,GAAKmH,EAASN,EAAQD,YAAY5G,GAAGoH,QACrCF,EAAQ,aAIJ,IAGLC,MAOLE,EAAkBzC,QAAQ,8BAM1BtC,EAAY,cACZ+E,EAAiB,KAEbC,EAAaV,EAAY,uBACxB,mBAAKA,EAAY5G,KAAOsH,OAE3BC,EAAeV,QAAQD,YAAY,gBAAaQ,aAC/C,gBACCA,EAAQR,EAAY5G,UACnBoH,IAAUG,GAAgBH,EAAuB,EAAfG,MAWhCC,EAAoB,cAC3BH,EAAiB,KAEbC,EAAaV,EAAY,uBACxB,gBAGCrF,EAAQf,EADCT,EAASC,IAIlByH,EAAQlG,EAAM6B,OAAO,SAACsE,EAAOhG,UAASgG,GAAS7H,EAAY6B,EAAK,GAAGhB,OAAS,EAAI,GAAG,GACnFiH,EAAiBpG,EAAMrC,OAAS0I,KAAKC,KAAKJ,EAAQ,GAElDL,EAAQR,EAAY5G,GAAKsH,SAG3BM,KAAKE,MAAMV,KAAWA,GAGnBA,GAASO,GAICd,QAAQD,YAAY,gBAAaQ,aAC/C,gBAIA,IAFC7F,EAAQf,EADCT,EAASC,IAGfG,EAAI,EAAGA,EAAIoB,EAAMrC,SAAUiB,EAAG,KAC/BuB,EAAOH,EAAMpB,MACfN,EAAY6B,EAAK,GAAGhB,WAClBP,IAAMoB,EAAMrC,OAAS,IAAMW,EAAY6B,EAAKvB,EAAE,GAAGO,cAC5C,MAGHV,EAAInB,OAAOwD,6BAAiBX,EAAKvB,GAAGO,eAAOgB,EAAKvB,EAAE,GAAGO,aACtD4B,EAAStC,UACL,IAGPG,WAKEH,EAAInB,OAAOwD,6BAAiBX,EAAKuB,IAAI,mBAAK8E,EAAErH,cAC7C4B,EAAStC,UACL,UAIJ,MAULmC,EAAkByE,EAAY,8BAA0BA,EAAY,gBAgGpE3E,EAAc,eAcb,IAZC+F,GACJ,OAAS,OAAS,SACT,OAAS,SACT,OAAS,SACT,OAAS,SACT,OAAS,cACT,OAAS,SACT,OAAS,GAId3E,EAAM,IAAItF,IACPoC,EAAI,EAAGA,EAAI6H,EAAK9I,OAAQiB,GAAK,MAI/B,IAHC0D,WACKb,EAAGgF,EAAK7H,GAAI4C,EAAGiF,EAAK7H,EAAE,GAAI2C,EAAGkF,EAAK7H,EAAE,KAEtC8H,EAAI,EAAGA,EAAI,IAAKA,EAAG,KACpBC,EAAIF,EAAK7H,EAAE8H,MACbC,EAAG,IACD7E,EAAI8E,IAAID,SACJ,IAAIE,MAAM,6BAA+BF,KAE7CG,IAAIH,EAAGrE,WAMV,gBACCjD,EAAMyC,EAAIiF,IAAI5H,IAAU,YAC1BE,QAAsBtC,IAAfsC,EAAIQ,WAETA,OAASkB,EAASzD,OAAOwD,cAAczB,EAAIV,OAAO8C,KAClDV,EAASzD,OAAOwD,cAAczB,EAAIV,OAAO6C,MACzCzB,QAAUV,EAAIV,OAAO4C,GAAKR,EAASzD,OAAOwD,cAAczB,EAAIV,OAAO4C,KAElElC,6aGxPX,SAAiB2H,OACTC,EAAa,mBAIVC,EAAO,KAAgB,IAARA,GAGlBC,EAASlK,SAASsI,cAAc,SAC/B6B,UAAY,oBAChBC,WAAWC,aAAaH,EAAQH,OAE7BO,EAAYtK,SAASsI,cAAc,SAC/B6B,UAAY,cACfI,YAAYD,OAEbE,EAAQxK,SAASsI,cAAc,SAC/B6B,UAAY,UACXI,YAAYC,GAGS,aAAxBxK,SAASyK,eACDnE,UAAUoE,IAAI,kBACjBhE,iBAAiB,OAAQ,kBAEpBJ,UAAUqE,OAAO,kBAIzBC,EAAa,oBACO9K,IAApBiK,EAAGjC,QAAQvH,cACHsK,QAAS,GACZ,MAEFtK,GAAcwJ,EAAGjC,QAAQvH,KAAnBuK,GAA0Bf,EAAGjC,QAAQgD,KAI5ChE,YAAciD,EAAG3E,MAAM3E,OAAO,EAAGF,OACjC8G,EAAQ9G,EAAOiK,EAAMO,wBAAwBnC,MAFpC,KAIT9B,YAAciD,EAAG3E,MAAM3E,OAAOF,EAAMuK,EAAKvK,OACzCqI,EAAQ4B,EAAMO,wBAAwBnC,MAL7B,GAOXA,EAAQ,IAAM5I,SAASgL,eAAe,iBAEhCpD,KAAK,sBAAuBgB,EAAO,WAAY4B,EAAM1D,eAGrD+D,OAASjC,GAAS,IAClBqC,MAAM5D,KAAOA,EAAO,OACpB4D,MAAMrC,MAAQA,EAAQ,OACtBqC,MAAMC,UAAY,eAAiBnB,EAAGoB,WAAa,OAIzDC,EAAW,SAAC7K,EAAMuK,MAClBvK,GAAQuK,SACT,OAAQ,KAAM,SAAU,OAAQ,SAASxH,QAAQ,0BAAcyG,EAAGjC,QAAQI,OACjE2C,QAAS,GACZ,SAE2BtK,EAAMuK,YAAtChD,QAAQvH,YAASuH,QAAQgD,UAC1BhD,QAAH,MAAsBiC,EAAG3E,MAAM3E,OAAOF,EAAMuK,EAAKvK,QAE1C,GAIH8K,EAAgBtB,EAAG3E,MAAM1E,OACzB4K,GAASnE,MAAOkE,EAAejE,IAAKiE,EAAejG,WAAOtF,GAC1DyL,EAAgB,gBACK,IAArBC,GACAzB,EAAG9C,iBAAmBqE,EAAMnE,OAC5B4C,EAAG7C,eAAiBoE,EAAMlE,KAC1B2C,EAAG3E,QAAUkG,EAAMlG,aACd,SAEmB2E,EAAG9C,eAAgB8C,EAAG7C,mBAA3CC,aAAaC,SAChBkE,EAAMlG,QAAU2E,EAAG3E,UAClBqG,cAAc,IAAIjM,YAAY,SAAUK,OAAQkK,EAAG3E,WAChDA,MAAQ2E,EAAG3E,OAIfkG,EAAMnE,QAAUmE,EAAMlE,kBACjB2C,EAAGjC,QAAH,cACAiC,EAAGjC,QAAH,OAEEwD,EAAMnE,MAAOmE,EAAMlE,OAElBd,UAAUoE,IAAI,WACrBpE,UAAUoE,IAAI,UACV,IAECpE,UAAUqE,OAAO,WACxBrE,UAAUqE,OAAO,aAGhBpK,EAAO+K,EAAMnE,MACb2D,EAAKQ,EAAMnE,MAITuE,GADW3B,EAAG3E,MAAM3E,OAAO6K,EAAMlE,KAAKlB,SACT8D,EAAWD,EAAG3E,MAAMvD,WAAWyJ,EAAMlE,SAEpEsE,EAAgB,MACXZ,EAAK,GAC0B,KAAhCf,EAAG3E,MAAMvD,WAAWiJ,EAAK,KADdA,GAKbA,EAAKvK,MACAuK,QAKJvK,EAAO,GACPyJ,EAAWD,EAAG3E,MAAMvD,WAAWtB,EAAO,MAD1BA,QAOZuK,EAAKf,EAAG3E,MAAM1E,QACdsJ,EAAWD,EAAG3E,MAAMvD,WAAWiJ,MADPA,GAO3BvK,GAAQuK,GAAMY,GAAkBF,GAChCJ,EAAS7K,EAAMuK,OAEdhD,QAAH,MAAsBiC,EAAGjC,QAAH,OAAuBiC,EAAG3E,MAAM3E,OAAOF,EAAMuK,EAAKvK,UACjEwJ,EAAGjC,QAAH,OAKL6D,EAAqB,SAACC,EAAQJ,MAE9BI,EAAOjC,IAAI,UAET2B,EAAMnE,QAAUmE,EAAMlE,IAAK,QAEWkE,EAAMnE,MAAOmE,EAAMlE,OAAvDH,sBAAmBC,sBAKvBqE,EAAcC,QAIZ3L,GAAUmF,KADL+E,EAAGjC,QAAQ7C,QAAU8E,EAAGjC,QAAQ+D,MAAQ,KAC7B5G,OAAQ,WAAY8E,EAAGjC,QAASN,MAAOuC,EAAGjC,QAAQN,SACrEiE,cAAc,IAAIjM,YAAY,SAAUK,cAIzC2L,yBAEEM,SACAF,EAAS,IAAIG,IACXC,EAAQ,YACPF,WACgBhM,IACZmM,UACC9M,OAAO+F,sBAAsB,cAC3B,OACW0G,EAAQJ,SAGzBI,EAAOlB,IAAI1E,EAAGkG,OAIT,6DACRC,MAAM,OAAO7I,QAAQ,mBAASyG,EAAGrD,iBAAiB3G,EAAOiM,WAG3DtF,iBAAiB,YAAa,YAC3BV,EAAGoG,kBAQR1F,iBAAiB,OAAQ,eACtBqD,EAAG9C,iBAAmBqE,EAAMnE,OAAS4C,EAAG9C,iBAAmBqE,EAAMlE,IAAK,QAChCkE,EAAMnE,MAAOmE,EAAMlE,OAAvDH,sBAAmBC,uBAKxBR,iBAAiB,UAAW,mBACrBV,EAAGkC,SACN,YACgB,YAGhB,IACC6B,EAAGjC,QAAQ7C,QAAU8E,EAAG9C,kBAAoB8C,EAAGjC,QAAQgD,MACtDW,cAAc,IAAIjM,YAAY,WAAYK,OAAQkK,EAAGjC,QAAQ7C,4BAWhE6G,SACEO,EAAkB,YACjBP,MACK3M,OAAO+F,sBAAsB,cAC3B,oBAKPwB,iBAAiB,SAAU2F,KAC/B3F,iBAAiB,QAAS2F,GAAkBC,SAAS,WAIpDC,EAAe,0BACKzM,IAApBiK,EAAGjC,QAAQvH,WAAwCT,IAAlBiK,EAAGjC,QAAQgD,UAA2B,MAEpEvK,GAAcwJ,EAAGjC,QAAQvH,KAAnBuK,GAA0Bf,EAAGjC,QAAQgD,GAC5C1F,EAAQ2E,EAAG3E,MAAM3E,OAAOF,EAAMuK,EAAKvK,MACrB0F,MAAMgB,eAAgBhB,MAAMiB,cAA3CC,OAAOC,OAENoF,EAAS1L,EAAKsE,MACN,MAAVoH,SAAyB,QACvBpH,MAAQa,MAAMb,MAAM3E,OAAO,EAAGF,GAAQiM,EAASvG,MAAMb,MAAM3E,OAAOqK,OAElE2B,EAAQ,mBACRC,EAAQ5B,IAEF4B,GAAS5B,EAAKvK,GAAQiM,EAAO9L,OAC5BgM,EAAQnM,MAETA,EAAOiM,EAAO9L,QAIjBgM,SAGHlF,cACAiE,cAAc,IAAIjM,YAAY,qBAEqCiN,EAAMtF,GAAQsF,EAAMrF,IAAjEnB,MAAMgB,oBAAgBhB,MAAMiB,uCAAjDC,aAAaC,YAED,IACV7G,EAAMA,EAAOiM,EAAO9L,SACtB,KAINgG,iBAAiB,WAAY,gBACxB9F,OAAQoF,EAAGnG,OAAOqM,KAAOlG,EAAGnG,OAAOoK,QAC5B,mBAAS0C,EAAgBvH,EAAOxE,GAAKwB,KAAO,SAIxDsE,iBAAiB,QAAS,gBACrBkG,EAAQ5G,EAAGnG,OAAOgN,OACnBN,EAAa,mBAAKK,QAGpB9E,QAAH,KAAqB9B,EAAGnG,OAAOgM,MAAQ9B,EAAGjC,QAAH,cAChCiC,EAAGjC,QAAH,WAIH7B,OF9RR,IAAMR,EAAM,iCAGRqH,EADS3N,OAAOqG,MAAMC,EAAM,YAAYsH,KAAK,mBAAO3K,EAAI4K,SACzCD,KAAK,gBAGhBE,SAED,IAAIC,KAAKC,MAEP,IADClI,EAASiI,EAAEzM,OAAO,EALL,GAMVkB,EAAI,EAAGA,GAAKsD,EAAOvE,SAAUiB,EAAG,KACjCyL,EAAOnI,EAAOxE,OAAO,EAAGkB,GAC1B0L,EAAOJ,EAAcG,GACpBC,MACIJ,EAAcG,OAEnBC,EAAK3M,OAXU,MAYZqB,KAAKmL,UAKT,SAASI,OAERC,KADED,EAAME,eACK/M,OApBA,GAqBfoE,EAAMoI,EAAcK,EAAM7M,OAAO,EArBlB,eAuBf8M,MACI1I,EAAI4I,OAAO,mBAAQ5B,EAAKpL,OAxBb,GAwBkCH,WAAWiN,QAE1D1I,EAAIJ,IAAI,mBACJhF,KAAQoM,EAAM6B,QAAWP,EAAStB,UAGrChH,EAAInE,OAASmE,EAAM,QAI1B8I,EAAkB,aAElB/G,SACEgH,EAAiB,SAAC5I,EAAMC,YAyBnB4I,EAAKzL,GACRwE,IAAYkH,KACE1L,aA1Bb4F,aAAapB,GACf5B,OAMC8I,EAAe3O,OAAO8I,WAAW,gBAC/B5C,EAAO,IAAIC,WACZC,OAAO,IAAKP,KACZO,OAAO,SAAUN,UACfO,MAAMC,EAAM,UAAWC,OAAQ,OAAQL,SAAO0H,KAAK,mBAAO3K,EAAI4K,SAAQD,KAAKc,IACjF,OACOC,IAEFf,KAAK,gBACPgB,EAAUC,EAAQhJ,GACjBC,MACO8I,EAAQN,OAAO,mBAAU9E,EAAA,OAAmB3D,OAEnD+I,YAlBW,QGvCnB,SAASpH,EAAOsH,OAETC,EAAkB,oBAClBC,EAAe,mBACftC,EACKA,EAAKuC,QAAQF,EAAiB,IAAIV,cAEpC,MAGLa,OAGI3H,iBAAiB,QAAS,gBAC1B4H,EAAItI,EAAGuI,UACO,WAAhBD,EAAEE,gBAEC,GAAIF,EAAExG,QAAF,SAAuB,KAC1B1C,EAAQ,UAAWkJ,EAAExG,SAAYwG,EAAExG,QAAF,OAAsBwG,EAAExG,QAAF,MAAsB,KAC7EjI,GAAUqM,KAAMoC,EAAExG,QAAF,SAAuBmC,KAAM7E,KAC7CqG,cAAc,IAAIjM,YAAY,YAAaK,gBAC5C,KACCA,GAAUgN,OAAQyB,EAAExH,YAAa+E,KAAMyC,EAAExG,QAAF,QACvC2D,cAAc,IAAIjM,YAAY,SAAUK,iBAK5C6G,iBAAiB,UAAW,eACjB,cAAXV,EAAGkC,IAAqB,KACpB/E,EAAQ8K,EAAQQ,cAAc,aAC3BtL,EAAMqE,aAKXd,iBAAiB,UAAW,mBAC1BV,EAAGkC,SACN,WACGV,WAGHxB,EAAGkC,IAAI5H,WAAW,cAEjB4D,EAAQmK,EAAY/O,QAAQU,SAAS0O,mBAC5B,IAAXxK,OAGAyK,YACW,cAAX3I,EAAGkC,OACI,EACW,eAAXlC,EAAGkC,QACJ,GAENyG,OACIJ,EAASrK,EAAQyK,EACnBJ,GAAU,GAAKA,EAASF,EAAY3N,UAC1B6N,GAAQ/G,gBAMT,YAAXxB,EAAGkC,OACI,MACJ,CAAA,GAAe,cAAXlC,EAAGkC,aACJ,UAIJ0G,EAAe5O,SAAS0O,cAAc3D,wBACtC8D,GAAQC,KAAMC,EAAAA,EAAUvI,OAAQ,MAElCwI,OAAYlP,EACZ8D,EAAYM,GACRN,GAAa+K,IAAU,GAAK/K,EAAYyK,EAAY3N,QAAQ,KAC5D8F,EAAS6H,EAAYzK,GACrBqL,EAAgBzI,EAAOuE,2BAEzB6D,EAAaM,MAAQD,EAAcC,aACrBpP,IAAdkP,MACUC,EAAcC,KAExBD,EAAcC,MAAQF,YAIpBF,EAAO1F,KAAK+F,IAAIF,EAAc5H,KAAOuH,EAAavH,SACpDyH,EAAOD,EAAKC,KAAM,QACQA,EAAMtI,KAA5BsI,YAAWtI,cAGjBqI,EAAKrI,SACFA,OAAOgB,aAKI1H,IAAdkP,GAA2BL,EAAQ,KAC/BnH,iBAMN4H,EAAe,KACfC,EAAQ,OACC,cACHvI,YAAc,KACVpG,OAAS,IACNqN,MAETuB,EAAuB,SAACC,EAASC,OAC/BzF,EAAK/J,SAASsI,cAAc,SAC/B6B,UAAY,aACFJ,EAAGzD,UAAUoE,IAAI8E,OAExBC,EAAKzP,SAASsI,cAAc,QAC/BxB,YAAcyI,IACdhF,YAAYkF,OAET5J,EAAU7F,SAASsI,cAAc,gBAC/B6B,UAAY,YACjBI,YAAY1E,KACP0E,YAAYR,GACblE,GAGH6J,EAAe,SAACC,EAAQC,OACtBpJ,EAASxG,SAASsI,cAAc,mBAC/BxB,YAAc8I,IACdrF,YAAY/D,KACPzE,KAAKyE,GACVA,MAIL6I,EAAM7H,QAAU6H,EAAMpK,OAAQ,KAC1B4K,KACAC,EAAuB,SAAC5D,EAAMlH,EAAM+K,OACpClK,EAAUgK,EAAU3D,GACnBrG,MACOqG,GAAQrG,EAAUyJ,EAAqBpD,EAAM,iBAEnD1F,EAASkJ,EAAa7J,EAASb,KAC9B8C,QAAP,SAA6BoE,EACzB6D,MACKjI,QAAP,MAA0BiI,IAIxB3N,EAAMuK,EAAgB0C,EAAM7H,YAE9B7E,OAAOG,SAAWgN,EAAqB,SAAU,YACjDnN,OAAOC,QAAUkN,EAAqB,SAAU,SAAY,OAC5DnN,OAAOE,QAAUiN,EAAqB,SAAU,eAAoB,QACpEnN,OAAOC,QAAUkN,EAAqB,SAAU,SAAY,OAC5DnN,OAAOE,QAAUiN,EAAqB,SAAU,eAAoB,MAEpE1N,EAAIM,UAAW,GACI,YAAa,cAC7B,IAAIf,EAAI,OAASA,GAAK,SAAWA,IACf,YAAatB,OAAOwD,cAAclC,GAAIA,KAOhEoM,OAAezK,QAAQ,gBAChB7D,EAAOkJ,EAAA,KACT9C,EAAU,OACd,QAAkBvC,QAAQ,YAEnBqJ,EAA0BqD,KAG1BnK,MAEOyJ,EAAqB7P,IAElBiQ,EAAa7J,EAASmK,GAC9BlI,QAAP,KAAyBrI,gBAKpB4G,KAAKC,UAAUC,OAAO,cAAe8H,EAAY3N,OAAS,OAO/DgG,iBAAiB,QAAS,iBACtBV,EAAGnG,QACYmF,KAAMqK,EAAMpK,YAI/ByB,iBAAiB,UAAW,gBAC1BmF,EAAOsC,EAAanI,EAAGnG,QACzBgN,EAAS,SAEZuC,OAAoBnM,KAAK,mBACpB0F,EAAOlJ,OAASoM,MACXlD,EAAO+E,QAAQ,IACjB,KAGLb,EAAQ,KACJhN,GAAUgN,SAAQhB,UAClBJ,cAAc,IAAIjM,YAAY,SAAUK,gBAGlDoG,MAAOgI,SCxNR,SAAStH,EAAOsJ,OACTC,EAAOD,EAASxB,cAAc,QAC9B0B,EAAQD,EAAKzB,cAAc,SAC3BjI,EAAS0J,EAAKzB,cAAc,UAE9BjH,EAAQ,KAENd,iBAAiB,QAAS,gBACxB2I,EAAQrJ,EAAGnG,OACXuQ,EAA4B,OAAff,EAAMrK,WAAiClF,IAAhBuP,EAAM7H,QACxC6H,EAAM7H,QACLqD,QAAUuF,EACfH,EAASpF,WACLzF,MAAQ,UAIZW,EAAU,cACPU,UAAY0J,EAAM/K,sBAEZ+G,MAAM,OAAO7I,QAAQ,mBAAQ6M,EAAMzJ,iBAAiBwF,EAAMnG,OAEpEW,iBAAiB,SAAU,cAC3B2J,mBAEE/J,UAAUoE,IAAI,aACbjE,UAAW,IACVA,UAAW,EASR6J,EAAgBH,EAAM/K,MAAOoC,GAAOuF,KAAK,qBAC1CzG,UAAUoE,IAAI,YACd,IACN6F,MAAM,qBACAjK,UAAUoE,IAAI,mBACb9C,KAAK,yBAA0B4I,IAChC,IACNzD,KAda,cACTzG,UAAUqE,OAAO,aAChBlE,UAAW,IACXrB,MAAQ,KACRqG,cAAc,IAAIjM,YAAY,aAYpCuN,KAAK,mBAAK,IAAI0D,QAAQ,SAACC,EAASC,UAAWxR,OAAO8I,WAAWyI,EAAS,SAAQ3D,KAAK,cAC5E5C,UAAY,QAIvBlE,MAAOgK","file":"support.min.js","sourcesContent":["\nif (!window.location.search || window.location.search.indexOf('ignore_check') === -1) {\n  const support = true && window.Map;\n  if (!support) {\n    window.location = 'error.html';\n  }\n}\n","\n/**\n * @fileoverview Polyfills included for Emojityper on non-module browsers.\n */\n\nif (typeof window.CustomEvent !== 'function') {\n  function CustomEvent(name, params) {\n    params = params || {bubbles: false, cancelable: false, detail: undefined};\n    const event = document.createEvent('CustomEvent');\n    event.initCustomEvent(name, params.bubbles, params.cancelable, params.detail);\n    return event;\n  }\n  CustomEvent.prototype = window.Event.prototype;\n  window.CustomEvent = CustomEvent;\n}\n\nif (!String.prototype.startsWith) {\n  String.prototype.startsWith = function(search, from) {\n    return this.substr(from || 0, search.length) === search;\n  };\n}\n\nif (!Array.from) {\n  Array.from = function(arg) {\n    // TODO: this isn't the whole polyfill, but it's good for now: just for rollup generated code\n    return Array.prototype.slice.call(arg);\n  };\n}\n","\n/**\n * @param {string} string to measure\n * @return {number} length of text in monospace units\n */\nconst measureText = (function() {\n  const canvas = document.createElement('canvas');\n  const context = canvas.getContext('2d');\n  context.font = '1px monospace';\n\n  let cache = {};\n  let count = 0;\n\n  return s => {\n    let result = cache[s];\n    if (result === undefined) {\n      cache[s] = result = context.measureText(s).width;\n      if (++count > 4000) {\n        // nb. at June 2017, there's about ~1,800 emojis including variations, so this number is\n        // probably greater than we'll ever use: still, empty if it's too big\n        cache = {};\n        count = 0;\n      }\n    }\n    return result;\n  };\n}());\n\n/**\n * @type {boolean} whether this platform probably has fixed width emoji\n */\nconst fixedWidthEmoji = Boolean(/Mac|Android|iP(hone|od|ad)/);\n\n/**\n * @param {string} string to measure\n * @return {boolean} whether this is a single char long (and probably a single emoji)\n */\nconst isSingle = (function() {\n  if (fixedWidthEmoji) {\n    // get a baseline emoji width: this is the well-supported 'FACE WITH TEARS OF JOY'\n    const emojiWidth = measureText('\\u{1f602}');\n    return s => measureText(s) === emojiWidth;\n  }\n  const invalidWidth = context.measureText('\\u{ffffd}').width;\n  return s => {\n    const width = measureText(s);\n    return width !== invalidWidth && width < invalidWidth * 2;\n  };\n}());\n\n/**\n * Is this string rendering correctly as an emoji or sequence of emojis? On variable width\n * platforms, this can take O(n).\n *\n * @param {string} string to check\n * @return {boolean} whether this is probably an emoji\n */\nexport const isExpectedLength = (function() {\n  if (fixedWidthEmoji) {\n    // use 'FACE WITH TEARS OF JOY'\n    const emojiWidth = measureText('\\u{1f602}');\n    return s => {\n      // emojis could be _smaller_ than expected, but not larger- and not random non-unit widths\n      const points = jsdecode(s);\n      const chars = splitEmoji(points);\n\n      // count flags, reduce expected by / 2\n      const flags = chars.reduce((total, char) => total += isFlagPoint(char[0].point) ? 1 : 0, 0);\n      const expectedLength = chars.length - Math.ceil(flags / 2);\n\n      const width = measureText(s) / emojiWidth;\n\n      // does this have non-emoji characters in it?\n      if (Math.floor(width) !== width) { return false; }\n\n      // otherwise, as long as we're equal or smaller\n      return width <= expectedLength;\n    };\n  }\n\n  const invalidWidth = context.measureText('\\u{ffffd}').width;\n  return s => {\n    const points = jsdecode(s);\n    const chars = splitEmoji(points);\n\n    for (let i = 0; i < chars.length; ++i) {\n      const char = chars[i];\n      if (isFlagPoint(char[0].point)) {\n        if (i === chars.length - 1 || !isFlagPoint(char[i+1].point)) {\n          return false;  // only one single flag point\n        }\n\n        const s = String.fromCodePoint(...char[i].point, char[i+1].point);\n        if (!isSingle(s)) {\n          return false;  // can't render this flag\n        }\n\n        ++i;  // eaten next flag char\n        continue;\n      }\n\n      // otherwise, measure this particular point and ensure it's single.\n      const s = String.fromCodePoint(...char.map(c => c.point));\n      if (!isSingle(s)) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n}());\n\n/**\n * True if the standard \"female\" icon can be varied with a diversity modifier. This is the basic\n * level of emoji diversity support, but doesn't imply support for all the professions.\n *\n * @type {boolean}\n */\nconst basicDiversity = (measureText('\\u{1f468}\\u{1f3fb}') === measureText('\\u{1f468}'));\n\n/**\n * @param {number} p\n * @return {boolean} whether the passed rune is a gender character\n */\nfunction isPointGender(p) {\n  return p === 0x2640 || p === 0x2642;\n}\n\n/**\n * @param {number} p\n * @return {boolean} whether the passed rune is a basic emoji person gender: Man or Woman\n */\nfunction isPersonGender(p) {\n  return p === 0x1f468 || p === 0x1f469;\n}\n\n/**\n * @param {number} p\n * @return {boolean} whether this is a subordinate member of a family sequence: boy/girl/baby\n */\nfunction isFamilyMember(p) {\n  return p === 0x1f476 || p === 0x1f466 || p === 0x1f467;\n}\n\n/**\n * @param {number} p\n * @return {boolean} whether the passed rune is a Variation_Selector\n */\nfunction isVariationSelector(p) {\n  return (p >= 0xfe00 && p <= 0xfe0f) || (p >= 0xe0100 && p <= 0xe01ef);\n}\n\n/**\n * @param {number} p\n * @return {boolean} whether the passed rune is a diversity selector (one of five skin tones)\n */\nfunction isDiversitySelector(p) {\n  return p >= 0x1f3fb && p <= 0x1f3ff;\n}\n\n/**\n * @param {number} p\n * @return {boolean} whether the passed rune is one of A-Z for flags\n */\nfunction isFlagPoint(p) {\n  return p >= 0x1f1e6 && p <= 0x1f1ff;\n}\n\n/**\n * @param {number} p\n * @return {boolean} whether the passed rune is probably not a modifier base\n */\nfunction unlikelyModifierBase(p) {\n  return p < 0x261d || isPointGender(p) || isVariationSelector(p) || isDiversitySelector(p) ||\n      isFlagPoint(p);\n}\n\n/**\n * Decodes a JavaScript string into Unicode code points.\n *\n * @param {string} s to decode\n * @return {!Array<number>} code points\n */\nfunction jsdecode(s) {\n  const len = s.length;\n  const points = [];\n\n  for (let i = 0; i < len;) {\n    const raw = s.charCodeAt(i++) || 0;\n    if (raw < 0xd800 || raw > 0xdbff || i === len) {\n      // not a high surrogate, or end of string\n    } else {\n      const extra = s.charCodeAt(i) || 0;\n      if ((extra & 0xfc00) === 0xdc00) {\n        // got a low surrogate, eat 2nd char\n        ++i;\n        points.push(0x10000 + (extra & 0x3ff) + ((raw & 0x3ff) << 10));\n        continue;\n      }\n    }\n    points.push(raw);\n  }\n\n  return points;\n}\n\n/**\n * Returns details about a character and whether it can be gender flipped to a single or neutral\n * gender. This contains emojis which, due to historical emoji reasons, aren't officially versions\n * of each other: e.g., Santa and Mrs. Claus, or Old {Man,Woman,Adult}.\n *\n * @param {number} point to look up in the other gender flips table\n * @return {{single: boolean, neutral: boolean, points: {f: number, m: number, n: number}}?}\n */\nconst genderFlip = (function() {\n  // TODO: covers F/M/neutral, but _not_ mixed (e.g. holding hands => no m/f combo)\n  const list = [\n    0x1f936, 0x1f385, 0,        // mrs. claus, santa\n    0x1f483, 0x1f57a, 0,        // dancers\n    0x1f470, 0x1f935, 0,        // bride, man in tuxedo\n    0x1f467, 0x1f466, 0,        // girl, boy\n    0x1f475, 0x1f474, 0x1f9d3,  // old {woman,man,adult}\n    0x1f46d, 0x1f46c, 0,        // women/men holding hands\n    0x1f478, 0x1f934, 0,        // princess, prince\n  ];\n\n  // build map with raw data only\n  const all = new Map();\n  for (let i = 0; i < list.length; i += 3) {\n    const data = {\n      points: {f: list[i], m: list[i+1], n: list[i+2]},\n    };\n    for (let j = 0; j < 3; ++j) {\n      const v = list[i+j];\n      if (v) {\n        if (all.has(v)) {\n          throw new Error('duplicate in gender list: ' + v);\n        }\n        all.set(v, data);\n      }\n    }\n  }\n\n  // return helper\n  return point => {\n    const out = all.get(point) || null;\n    if (out && out.single === undefined) {\n      // do the heavy lifting only when first fetched\n      out.single = isSingle(String.fromCodePoint(out.points.f)) &&\n          isSingle(String.fromCodePoint(out.points.m));\n      out.neutral = out.points.n && isSingle(String.fromCodePoint(out.points.n));\n    }\n    return out;\n  };\n}());\n\n/**\n * Splits a single emoji into raw characters, removing variants or diversity modifiers. Each\n * sub-array represents a character previously split by ZWJs.\n *\n * @param {!Array<number>} points\n * @return {!Array<!Array<{point: number, suffix: number}>>}\n */\nfunction splitEmoji(points) {\n  if (!points.length) {\n    return [];\n  }\n  let curr = [{point: points[0], suffix: 0}];\n  const out = [curr];\n\n  // TODO: doesn't deal with flags or regional letters\n  // flags are weird: U + N + A, for instance, will render the Namibia flag where the UN flag is\n  // not supported (but the UN flag where it is)- taking the left-most valid code\n  // NOTE: the regional flag letters are seen as _emoji_ on their own, at least on Mac.\n\n  for (let i = 1; i < points.length; ++i) {\n    const check = points[i];\n\n    if (isFlagPoint(curr[curr.length-1].point)) {\n      // previous was a flag, create a new one\n    } else if (isDiversitySelector(check) || isVariationSelector(check)) {\n      // store in suffix\n      curr[curr.length-1].suffix = check;\n      continue;\n    } else if (check === 0x200d) {\n      // push next char onto curr\n      const next = points[++i];\n      next && curr.push({point: next, suffix: 0});\n      continue;\n    }\n\n    // new character, reset\n    curr = [{point: check, suffix: 0}];\n    out.push(curr);\n  }\n  return out;\n}\n\n/**\n * Analyses or modifes an emoji string for modifier support: diversity and gender.\n *\n * This might be O(n), including the cost of measuring every individual character via measureText.\n *\n * @param {string} s\n * @param {{diversity: undefined|number, gender: undefined|string}=} opt_op\n * @return {out: (string|undefined), diversity: boolean, gender: {single: boolean, double: boolean, neutral: boolean}}\n */\nexport function modify(s, opt_op) {\n  const points = jsdecode(s);\n  const stats = {diversity: false, gender: {single: false, double: false, neutral: false}};\n\n  // split out gender modifierss and other variations with splitEmoji, walk chars\n  const chars = splitEmoji(points);\n  const record = (opt_op ? [] : null);\n  chars.some((char, i) => {\n    const first = char[0].point;\n    let genderable = 0;\n    let family = false;\n\n    // search for existing gender characters\n    char.forEach(ch => {\n      const p = ch.point;\n      if (isPointGender(p)) {\n        // we can remove or replace the point\n        stats.gender.single = true;\n        stats.gender.neutral = true;\n      } else if (isPersonGender(p)) {\n        // easily swappable person\n        stats.gender.single = true;\n        if (++genderable >= 2) {\n          stats.gender.double = true;\n        }\n      } else if (isFamilyMember(p) && genderable) {\n        // this run is a family (child and already has parent), so it can't be made diverse\n        family = true;\n      } else {\n        // look for potential gender flips\n        const flip = genderFlip(p);\n        if (flip) {\n          stats.gender.single |= flip.single;\n          stats.gender.neutral |= flip.neutral;\n        }\n      }\n    });\n\n    // check for professions ('non family person'): single initial person gender, not a family\n    const isSinglePerson =\n        genderable ? (isPersonGender(first) && genderable === 1 && !family) : undefined;\n    if (isSinglePerson) {\n      stats.diversity = basicDiversity;\n    }\n    if (record) {\n      // true: is a 'non family person', aka profession or disembodied head (diversity OK)\n      // false: is a family or other combined group of persons (no diversity)\n      // undefined: something else\n      record[i] = isSinglePerson;\n    }\n\n    // check for early exhaustive answer\n    if ((stats.diversity || !basicDiversity) && stats.gender.neutral) {\n      // ... don't finish 'some' early if we're recording gender data\n      return !record && stats.gender.single && stats.gender.double;\n    }\n\n    // skip if profession, low emojis (everything below Emoji_Modifier_Base) and male/female signs\n    if (isSinglePerson === false || unlikelyModifierBase(first)) { return; }\n\n    // do slow measure checks\n    // TODO: can we use \\p{Modifier_Base} as a faster check than measureText for +ve case?\n    const candidate = String.fromCodePoint(first);\n    if (basicDiversity && !stats.diversity && isSingle(candidate + '\\u{1f3fb}')) {\n      stats.diversity = true;\n    }\n    if (!stats.gender.neutral && isSingle(candidate + '\\u{200d}\\u{2640}\\u{fe0f}')) {\n      stats.gender.neutral = true;\n      stats.gender.single = true;\n    }\n  });\n\n  // early out without op\n  if (!opt_op) {\n    return stats;\n  }\n\n  // gender helper: modifies passed character to apply next gender (or returns new ch)\n  const nextGenderPoint = (function() {\n    const g = opt_op.gender || '';\n    let previousMaster;\n    let index;\n    return (master, opt_point, opt_allowOtherFlip) => {\n      if (previousMaster === undefined || master !== previousMaster) {\n        previousMaster = master;\n        index = 0;\n      } else {\n        ++index;\n      }\n      const next = g ? g[index % g.length] : '';\n      const point = opt_point || 0;\n      if (isPersonGender(point)) {\n        // if this is a person, return the alternative person (or make no change)\n        return next ? (next === 'm' ? 0x1f468 : 0x1f469) : point;\n      } else if (!point || isPointGender(point)) {\n        // if this is a point, return the alternative point (or clear)\n        return next ? (next === 'm' ? 0x2642 : 0x2640) : 0;\n      } else if (opt_allowOtherFlip) {\n        // do other gender flips: note that some of these have F/M/N, but not all have N\n        const flip = genderFlip(point);\n        if (flip) {\n          if (!next && flip.neutral) {\n            return flip.points.n;\n          } else if (next && flip.single) {\n            return next === 'm' ? flip.points.m : flip.points.f;\n          }\n        }\n      }\n      // didn't consume anything\n      --index;\n      return point;\n    };\n  }());\n\n  // walk over all chars, apply change\n  const out = chars.map((char, i) => {\n    const points = [];  // used as nonce, declare first\n    const isSinglePerson = record[i];\n    const first = char[0].point;\n\n    if (opt_op.gender !== undefined) {\n      // replace/remove existing male/female characters\n      // nb. this removes orphaned gender point characters\n      const allowOtherFlip = (isSinglePerson === undefined);  // not for family/profession\n      char.forEach(ch => ch.point = nextGenderPoint(points, ch.point, allowOtherFlip));\n\n      // under various conditions, add a gender modifier to a single point\n      if (isSinglePerson === undefined && char.length === 1 && !isPointGender(first)) {\n        const genderPoint = nextGenderPoint(points);\n        if (genderPoint && isSingle(String.fromCodePoint(first) + '\\u{200d}\\u{2640}\\u{fe0f}')) {\n          char.push({suffix: 0xfe0f, point: genderPoint});\n        }\n      }\n    }\n\n    // apply diversity\n    if (opt_op.diversity !== undefined) {\n      char.forEach((ch, i) => {\n        if (isDiversitySelector(ch.suffix)) {\n          // always tweak existing diversity modifiers\n          ch.suffix = opt_op.diversity;\n        } else if (i === 0 && basicDiversity && isSinglePerson !== false) {\n          // if it's the first point in a non-family, try to apply diversity\n          if (isSinglePerson || isSingle(String.fromCodePoint(first) + '\\u{1f3fb}')) {\n            ch.suffix = opt_op.diversity;\n          }\n        }\n      });\n    }\n\n    // flatten into actual codepoints again\n    char.forEach(ch => {\n      if (ch.point) {\n        points.length && points.push(0x200d);\n        points.push(ch.point);\n        ch.suffix && points.push(ch.suffix);\n      }\n    });\n    return points;\n  }).reduce((all, points) => all.concat(points), []);\n\n  stats.out = String.fromCodePoint(...out);\n  return stats;\n};\n","const api = 'https://emojityper.appspot.com';\n\nconst data = window.fetch(api + '/popular').then(out => out.json());\nlet indexed = data.then(emojimap => {\n  const prefixLength = 3;   // generate prefixes up to this length\n  const maxSuggestions = 10;  // only generate this many suggestions\n  const prefixSuggest = {};\n\n  for (let k in emojimap) {\n    const prefix = k.substr(0, prefixLength);\n    for (let i = 1; i <= prefix.length; ++i) {\n      const part = prefix.substr(0, i);\n      let opts = prefixSuggest[part];\n      if (!opts) {\n        opts = prefixSuggest[part] = [];\n      }\n      if (opts.length < maxSuggestions) {\n        opts.push(k);\n      }\n    }\n  }\n\n  return function(typed) {\n    typed = typed.toLowerCase();\n    const rest = typed.substr(prefixLength);\n    let all = prefixSuggest[typed.substr(0, prefixLength)] || [];\n\n    if (rest) {\n      all = all.filter(word => word.substr(prefixLength).startsWith(rest));\n    }\n    all = all.map(word => {\n      return {'name': word, 'options': emojimap[word] || []};\n    });\n\n    return all.length ? all : null;\n  }\n});\n\nlet requestCallback = function() {};\n\nlet timeout;  // timeout handler for secondary query\nconst performRequest = (text, prefix) => {\n  window.clearTimeout(timeout);\n  if (!text) {\n    requestCallback(null);\n    return;\n  }\n\n  // TODO: only send extra query if there's not enough results, or the user hits 'more'\n  const localTimeout = window.setTimeout(_ => {\n    const data = new FormData();\n    data.append('q', text);\n    data.append('prefix', prefix)\n    window.fetch(api + '/query', {method: 'POST', data}).then(out => out.json()).then(send);\n  }, 2000);\n  timeout = localTimeout;\n\n  indexed.then(suggest => {\n    let results = suggest(text);\n    if (!prefix) {\n      results = results.filter(result => result['name'] === text);\n    }\n    send(results);\n  });\n\n  // nb. at end to hoist above 'localTimeout'\n  function send(out) {\n    if (timeout === localTimeout) {\n      requestCallback(out);\n    }\n  }\n};\n\nexport function request(text, prefix) {\n  window.requestAnimationFrame(_ => {\n    performRequest(text, prefix);\n  });\n}\n\nexport function submit(name, value) {\n  // const data = `name=${name}&emoji=${value}`;\n  // FIXME: we've disabled CORS for now; the response is actually useless anyway\n  // FIXME: however, the client now thinks this succeeds even when it 400s\n  const data = new FormData();\n  data.append('name', name);\n  data.append('emoji', value);\n  return window.fetch(api + '/name', {method: 'POST', data, mode: 'no-cors'});\n}\n\nexport function callback(callback) {\n  requestCallback = callback;\n}\n","\nconst all = Array.prototype.slice.call(buttons.querySelectorAll('button'));\n\nconst handler = ev => {\n  const text = (ev ? ev.detail : typer.value).trim();\n  const hasValue = Boolean(text);\n  document.body.classList.toggle('has-value', hasValue);\n  all.forEach(button => button.disabled = !hasValue);\n};\n\ntyper.addEventListener('value', handler);\nhandler();\n\n// copy handler\n(function(button, input) {\n  let timeout;\n  const defaultText = button.textContent;\n  const spaceRe = /\\s*/;\n\n  const copy = _ => {\n    const [start, end] = [input.selectionStart, input.selectionEnd];\n\n    // find start/end of content (trim, but find positions)\n    let left = 0;\n    let right = input.value.length;\n    if (input.selectionStart !== input.selectionEnd) {\n      left = input.selectionStart;\n      right = input.selectionEnd;\n    }\n    left += spaceRe.exec(input.value.substr(left))[0].length;\n    right = left + input.value.substr(left, right - left).trim().length;\n    if (right <= left) { return false; }\n\n    input.focus();\n    input.selectionStart = left;\n    input.selectionEnd = right;\n\n    let ok = false;\n    try {\n      ok = document.execCommand('copy');\n    } catch(e) {\n      console.warn('could not copy', e);\n      ok = false;\n    }\n    // restore previous selection\n    [input.selectionStart, input.selectionEnd] = [start, end];\n\n    if (!ok) { return true; }\n    console.info('copied', input.value.substr(left, right));\n\n    // show message\n    button.textContent = button.dataset.copied;\n    window.clearTimeout(timeout);\n    timeout = window.setTimeout(ev => {\n      button.textContent = defaultText;\n    }, 500);\n  };\n\n  input.addEventListener('keydown', ev => {\n    if (ev.key == 'Enter') {\n      button.click();\n      input.focus();\n    }\n  });\n  button.addEventListener('click', ev => {\n    copy();\n    button.focus();\n  });\n}(copy, typer));\n\n","\nimport * as modifier from './lib/modifier.js';\n\n// word focus handler\nfunction upgrade(el) {\n  const isWordCode = code => {\n    // FIXME: turns out matching non-emoji is hard\n    // TODO: this RegExp _might_ work but it needs transpiling-\n    // new RegExp(/(?:[\\p{Letter}\\p{Number}\\p{Punctuation}](?!\\u{fe0f}?\\u{20e3}))+/u);\n    return code < 5000 && code != 32;\n  };\n\n  const helper = document.createElement('div');\n  helper.className = 'overflow-helper';\n  el.parentNode.insertBefore(helper, el);\n\n  const underline = document.createElement('div');\n  underline.className = 'underline';\n  helper.appendChild(underline);\n\n  const sizer = document.createElement('div');\n  sizer.className = 'sizer';\n  helper.appendChild(sizer);\n\n  // hide underline until load: the font used might not be ready, so it's probably out of whack\n  if (document.readyState !== 'complete') {\n    underline.classList.add('loading');\n    window.addEventListener('load', ev => {\n      renderLine();\n      underline.classList.remove('loading');\n    });\n  }\n\n  const renderLine = _ => {\n    if (el.dataset.from === undefined) {\n      underline.hidden = true;\n      return false;\n    }\n    const [from, to] = [+el.dataset.from, +el.dataset.to];\n\n    // otherwise, record and draw the line\n    const indent = 15;  // FIXME: from CSS, to match `text-indent`\n    sizer.textContent = el.value.substr(0, from);\n    const left = (from ? sizer.getBoundingClientRect().width : indent);\n\n    sizer.textContent = el.value.substr(from, to - from);\n    const width = sizer.getBoundingClientRect().width - indent;\n\n    if (width < 0 && !document.getElementById('less')) {\n      // nb. this seems to happen in dev with lesscss\n      console.warn('invalid sizer width', width, 'for text', sizer.textContent);\n    }\n\n    underline.hidden = width <= 0;\n    underline.style.left = left + 'px';\n    underline.style.width = width + 'px';\n    underline.style.transform = 'translateX(-' + el.scrollLeft + 'px)';\n  };\n\n  // force selection\n  const setRange = (from, to) => {\n    if (from >= to) {\n      ['from', 'to', 'prefix', 'word', 'focus'].forEach(key => delete(el.dataset[key]));\n      underline.hidden = true;\n      return false;\n    }\n    [el.dataset.from, el.dataset.to] = [from, to];\n    el.dataset['focus'] = el.value.substr(from, to - from);\n    renderLine();\n    return true;\n  };\n\n  // state/handler keep track of the current focus word (plus scroll position, if input is big)\n  const initialLength = el.value.length;\n  const state = {start: initialLength, end: initialLength, value: undefined};\n  const changeHandler = permitNextChange => {\n    if (permitNextChange !== false &&\n        el.selectionStart === state.start &&\n        el.selectionEnd === state.end &&\n        el.value === state.value) {\n      return true;  // already at this state\n    }\n    [state.start, state.end] = [el.selectionStart, el.selectionEnd];\n    if (state.value !== el.value) {\n      el.dispatchEvent(new CustomEvent('value', {detail: el.value}));\n      state.value = el.value;\n    }\n\n    // range selection, magic\n    if (state.start !== state.end) {\n      delete(el.dataset['prefix']);\n      delete(el.dataset['word']);\n\n      setRange(state.start, state.end);\n\n      underline.classList.add('range');\n      el.classList.add('range');\n      return false;\n    }\n    underline.classList.remove('range');\n    el.classList.remove('range');\n\n    // calculate from/to locally\n    let from = state.start;\n    let to = state.start;\n\n    // are we at the end (only have spaces until end)?\n    const isAtEnd = !el.value.substr(state.end).trim();\n    const isNotWordAfter = isAtEnd || !isWordCode(el.value.charCodeAt(state.end));\n\n    if (isNotWordAfter) {\n      for (; to > 0; --to) {\n        if (el.value.charCodeAt(to - 1) !== 32) {\n          break;\n        }\n      }\n      if (to < from) {\n        from = to;\n      }\n    }\n\n    // walk backwards while the previous character is a word\n    for (; from > 0; --from) {\n      if (!isWordCode(el.value.charCodeAt(from - 1))) {\n        break;\n      }\n    }\n\n    // walk forwards while the next char is not a space\n    for (; to < el.value.length; ++to) {\n      if (!isWordCode(el.value.charCodeAt(to))) {\n        break;\n      }\n    }\n\n    // if it's invalid, but there's not a word after, and we were permitted, ignore\n    if (from >= to && isNotWordAfter && permitNextChange) { return; }\n    if (setRange(from, to)) {\n      // if the range was valid, update the prefix/focus but delete the word (in typing state)\n      el.dataset['focus'] = el.dataset['prefix'] = el.value.substr(from, to - from);\n      delete(el.dataset['word']);\n    }\n  };\n\n  // runs change handler and emits the 'word' event as appropriate\n  const mergedEventHandler = (events, permitNextChange) => {\n    // if there was a focus event, don't let the browser take over: reset previous known good\n    if (events.has('focus')) {\n      // only if it wasn't a range selection (otherwise clicking back retains range, weird)\n      if (state.start === state.end) {\n        // TODO: this sets on initial load, even though it probably doesn't need to\n        [el.selectionStart, el.selectionEnd] = [state.start, state.end];\n      }\n    }\n\n    // run change handler: if true, nothing changed\n    if (changeHandler(permitNextChange)) { return; }\n\n    // send query: prefix or whole-word\n    let text = el.dataset.prefix || el.dataset.word || null;\n    const detail = {text, prefix: 'prefix' in el.dataset, focus: el.dataset.focus};\n    el.dispatchEvent(new CustomEvent('query', {detail}));\n  };\n\n  // dedup listeners on a rAF\n  let permitNextChange;  // FIXME: global-ish scope is ugly\n  (function() {\n    let frame;\n    let events = new Set();  // records the events that occured to cause this\n    const dedup = ev => {\n      if (!frame) {\n        permitNextChange = undefined;\n        events.clear();\n        frame = window.requestAnimationFrame(_ => {\n          frame = null;\n          mergedEventHandler(events, permitNextChange);\n        });\n      }\n      ev && events.add(ev.type);\n    };\n\n    // lots of listeners for a million different change reasons\n    const rest = 'change keydown keypress focus click mousedown select input';\n    rest.split(/\\s+/).forEach(event => el.addEventListener(event, dedup));\n    dedup();\n\n    el.addEventListener('mousemove', ev => {\n      if (ev.which) {\n        dedup();\n      }\n    })\n\n  }());\n\n  // on blur, after a backspace, Chrome moves the start/end selection: fix it\n  el.addEventListener('blur', ev => {\n    if (el.selectionStart !== state.start || el.selectionStart !== state.end) {\n      [el.selectionStart, el.selectionEnd] = [state.start, state.end];\n    }\n  });\n\n  // add a non-deduped keydown handler, to run before others and intercept space\n  el.addEventListener('keydown', ev => {\n    switch (ev.key) {\n    case 'Escape':\n      permitNextChange = false;  // force next change\n      break;\n\n    case ' ':\n      if (el.dataset.prefix && el.selectionStart === +el.dataset.to) {\n        el.dispatchEvent(new CustomEvent('request', {detail: el.dataset.prefix}));\n      }\n\n      // TODO: do this to prevent actually space being hit (as \"Sam Prefers\")\n      //ev.preventDefault();\n      break;\n    }\n  });\n\n  // dedup re-rendering calls\n  (function() {\n    let frame;\n    const dedupRenderLine = _ => {\n      if (!frame) {\n        frame = window.requestAnimationFrame(_ => {\n          frame = null;\n          renderLine();\n        });\n      }\n    };\n    window.addEventListener('resize', dedupRenderLine);\n    el.addEventListener('wheel', dedupRenderLine, {passive: true});\n  }());\n\n  // replace helper\n  const replaceFocus = call => {\n    if (el.dataset.from === undefined || el.dataset.to === undefined) { return false; }\n\n    const [from, to] = [+el.dataset.from, +el.dataset.to];\n    const value = el.value.substr(from, to - from);\n    let [start, end] = [typer.selectionStart, typer.selectionEnd];\n\n    const update = call(value);\n    if (update == null) { return false; }\n    typer.value = typer.value.substr(0, from) + update + typer.value.substr(to);\n\n    const drift = where => {\n      if (where > to) {\n        // after the update\n        where = where - (to - from) + update.length;\n      } else if (where > from) {\n        // during the update\n        where = from + update.length;\n      } else {\n        // do nothing, was before\n      }\n      return where;\n    };\n\n    typer.focus();\n    typer.dispatchEvent(new CustomEvent('change'));  // nb. updates from/to (from won't change)\n    // pretend we were like this all along\n    [state.start, state.end] = [typer.selectionStart, typer.selectionEnd] = [drift(start), drift(end)];\n\n    permitNextChange = true;\n    setRange(from, from + update.length);\n    return true;\n  };\n\n  // handle 'modifier' event: apply modifiers to the focus word, if any\n  el.addEventListener('modifier', ev => {\n    const arg = {[ev.detail.type]: ev.detail.code};\n    replaceFocus(value => modifier.modify(value, arg).out || '');\n  });\n\n  // handle 'emoji' event: if there's a current focus word, then replace it with the new emoji \\o/\n  el.addEventListener('emoji', ev => {\n    const emoji = ev.detail.choice;\n    if (!replaceFocus(_ => emoji)) { return; }\n\n    // if this was a prefix match, now it's a word match (the word masks the emoji)\n    el.dataset['word'] = ev.detail.word || el.dataset['prefix'];\n    delete(el.dataset['prefix']);\n  });\n}\n\nupgrade(typer);\n","\nimport * as provider from './lib/provider.js';\nimport * as modifier from './lib/modifier.js';\n\n// suggestion handler\n(function(input, chooser) {\n  // nb. this puncutation list is just misc stuff needed by emojimap\n  const invalidLetterRe = /[^\\w:\\.,$%^\\-']+/g;\n  const simplifyWord = word => {\n    if (word) {\n      return word.replace(invalidLetterRe, '').toLowerCase();\n    }\n    return null;\n  };\n\n  let buttonArray = [];\n\n  // button click handler\n  chooser.addEventListener('click', ev => {\n    const b = ev.target;\n    if (b.localName !== 'button') {\n      // ignore\n    } else if (b.dataset['modifier']) {\n      const value = 'value' in b.dataset ? (+b.dataset['value'] || b.dataset['value']) : null;\n      const detail = {type: b.dataset['modifier'], code: value};\n      input.dispatchEvent(new CustomEvent('modifier', {detail}));\n    } else {\n      const detail = {choice: b.textContent, word: b.dataset['word']};\n      input.dispatchEvent(new CustomEvent('emoji', {detail}));\n    }\n  });\n\n  // handle moving down from input\n  input.addEventListener('keydown', ev => {\n    if (ev.key === 'ArrowDown') {\n      const first = chooser.querySelector('button');\n      first && first.focus();\n    }\n  });\n\n  // handle keyboard navigation inside chooser\n  chooser.addEventListener('keydown', ev => {\n    switch (ev.key) {\n    case 'Escape':\n      input.focus();\n      break;\n    }\n    if (!ev.key.startsWith('Arrow')) { return; }\n\n    const index = buttonArray.indexOf(document.activeElement);\n    if (index === -1) { return; }\n\n    // handle l/r keys\n    let delta;\n    if (ev.key === 'ArrowLeft') {\n      delta = -1;\n    } else if (ev.key === 'ArrowRight') {\n      delta = +1;\n    }\n    if (delta) {\n      const target = index + delta;\n      if (target >= 0 && target < buttonArray.length) {\n        buttonArray[target].focus();\n      }\n      return;  // done\n    }\n\n    // handle u/d keys\n    if (ev.key === 'ArrowUp') {\n      delta = -1;\n    } else if (ev.key === 'ArrowDown') {\n      delta = +1;\n    } else {\n      return;\n    }\n    const previousRect = document.activeElement.getBoundingClientRect();\n    const best = {dist: Infinity, button: null};\n\n    let targetTop = undefined;\n    let candidate = index;\n    while ((candidate += delta) >= 0 && candidate < buttonArray.length) {\n      const button = buttonArray[candidate];\n      const candidateRect = button.getBoundingClientRect();\n\n      if (previousRect.top === candidateRect.top) { continue; }\n      if (targetTop === undefined) {\n        targetTop = candidateRect.top;\n      }\n      if (candidateRect.top !== targetTop) {\n        break;  // no more good candidates\n      }\n\n      const dist = Math.abs(candidateRect.left - previousRect.left);\n      if (dist < best.dist) {\n        [best.dist, best.button] = [dist, button];\n      }\n    }\n    if (best.button) {\n      best.button.focus();\n      return;\n    }\n\n    // if we were at top and going -ve, then return to input\n    if (targetTop === undefined && delta < 0) {\n      input.focus();\n      return;\n    }\n\n  });\n\n  let savedResults = null;\n  let query = null;\n  const show = results => {\n    chooser.textContent = '';\n    buttonArray.length = 0;\n    savedResults = results;\n\n    const createOptionsButtons = (heading, opt_class) => {\n      const el = document.createElement('div');\n      el.className = 'options';\n      opt_class && el.classList.add(opt_class);\n\n      const h4 = document.createElement('h4');\n      h4.textContent = heading;\n      el.appendChild(h4);\n\n      const buttons = document.createElement('div');\n      buttons.className = 'buttons';\n      el.appendChild(buttons);\n      chooser.appendChild(el);\n      return buttons;\n    };\n\n    const createButton = (holder, content) => {\n      const button = document.createElement('button');\n      button.textContent = content;\n      holder.appendChild(button);\n      buttonArray.push(button);\n      return button;\n    };\n\n    // if there's a focus but it's not a prefix (which implies that it's text-only)\n    if (query.focus && !query.prefix) {\n      const modifiers = {};\n      const createModifierButton = (type, text, opt_value) => {\n        let buttons = modifiers[type];\n        if (!buttons) {\n          modifiers[type] = buttons = createOptionsButtons(type, 'modifier');\n        }\n        const button = createButton(buttons, text);\n        button.dataset['modifier'] = type;\n        if (opt_value) {\n          button.dataset['value'] = opt_value;\n        }\n      };\n\n      const out = modifier.modify(query.focus);\n\n      out.gender.neutral && createModifierButton('gender', '\\u{2014}');\n      out.gender.single && createModifierButton('gender', '\\u{2640}', 'f');\n      out.gender.double && createModifierButton('gender', '\\u{2640}\\u{2642}', 'fm');\n      out.gender.single && createModifierButton('gender', '\\u{2642}', 'm');\n      out.gender.double && createModifierButton('gender', '\\u{2642}\\u{2640}', 'mf');\n\n      if (out.diversity) {\n        createModifierButton('diversity', '\\u{2014}');\n        for (let i = 0x1f3fb; i <= 0x1f3ff; ++i) {\n          createModifierButton('diversity', String.fromCodePoint(i), i);\n        }\n      }\n    }\n\n    // FIXME: slowly add these (over frames), to amortize rendering hit\n    // FIXME: we still get duplicates- some which are just force emoji / missing\n    (results || []).forEach(result => {\n      const name = result['name'];\n      let buttons = null;\n      result['options'].forEach(option => {\n        // TODO: If a user has allowed it, render all emojis (even invalid) anyway.\n        if (!modifier.isExpectedLength(option)) {\n          return;\n        }\n        if (!buttons) {\n          // create if we haven't already got it\n          buttons = createOptionsButtons(name);\n        }\n        const button = createButton(buttons, option);\n        button.dataset['word'] = name;\n      });\n    });\n\n    // set global class to indicate chooser visible\n    document.body.classList.toggle('has-chooser', buttonArray.length > 0);\n  };\n\n  // set global callback for show\n  provider.callback(show);\n\n  // handler for a prefix search\n  input.addEventListener('query', ev => {\n    query = ev.detail;\n    provider.request(query.text, query.prefix);\n  });\n\n  // request an autocomplete, the user has just kept typing\n  input.addEventListener('request', ev => {\n    const word = simplifyWord(ev.detail);\n    let choice = null;\n\n    (savedResults || []).some(result => {\n      if (result.name !== word) { return false; }\n      choice = result.options[0];\n      return true;\n    });\n\n    if (choice) {\n      const detail = {choice, word};\n      input.dispatchEvent(new CustomEvent('emoji', {detail}));\n    }\n  });\n}(typer, chooser));\n","\nimport * as provider from './lib/provider.js';\n\n// advanced handler\n(function(input, advanced) {\n  const form = advanced.querySelector('form');\n  const namer = form.querySelector('input');\n  const button = form.querySelector('button');\n\n  let focus = '';\n\n  input.addEventListener('query', ev => {\n    const query = ev.detail;\n    const selection = (query.text === null && query.focus !== undefined);\n    focus = query.focus;\n    advanced.hidden = !selection;\n    if (advanced.hidden) {\n      namer.value = '';\n    }\n  });\n\n  const handler = ev => {\n    button.disabled = !namer.value;\n  };\n  'input change'.split(/\\s+/).forEach(type => namer.addEventListener(type, handler));\n\n  form.addEventListener('submit', ev => {\n    ev.preventDefault();\n\n    form.classList.add('pending');\n    namer.disabled = true;\n    button.disabled = true;\n\n    const cleanup = _ => {\n      form.classList.remove('pending');\n      namer.disabled = false;\n      namer.value = '';\n      namer.dispatchEvent(new CustomEvent('change'));\n    };\n\n    const p = provider.submit(namer.value, focus).then(_ => {\n      button.classList.add('success');\n      return false;\n    }).catch(err => {\n      button.classList.add('failure');\n      console.warn('failed to submit emoji', err)\n      return true;\n    }).then(cleanup);\n\n    p.then(_ => new Promise((resolve, reject) => window.setTimeout(resolve, 2000))).then(_ => {\n      button.className = '';\n    });\n  });\n\n}(typer, advanced));\n"]}