{"version":3,"sources":["src/lib/modifier.js","src/input.js","src/lib/prefixgen.js","src/lib/results.js","src/lib/provider.js","src/adverts.js","src/polyfill.js","src/buttons.js","src/options.js","src/page.js","src/sw.js"],"names":["isPointGender","p","isPersonGender","isFamilyMember","isVariationSelector","isDiversitySelector","isFlagPoint","unlikelyModifierBase","jsdecode","s","len","length","points","i","raw","charCodeAt","extra","push","splitEmoji","curr","point","suffix","out","check","next","modify","opt_op","stats","tone","gender","single","double","neutral","chars","record","some","char","first","genderable","family","forEach","ch","flip","genderFlip","isSinglePerson","undefined","basicDiversity","candidate","String","fromCodePoint","isSingle","nextGenderPoint","g","previousMaster","index","master","opt_point","opt_allowOtherFlip","n","m","f","map","allowOtherFlip","genderPoint","reduce","all","concat","datasetSafeDelete","el","keys","d","dataset","key","upgrade","isWordCode","code","helper","document","createElement","className","parentNode","insertBefore","underline","appendChild","measureText","sizer","nonce","text","textContent","offsetLeft","readyState","classList","add","window","addEventListener","ev","renderLine","remove","from","hidden","to","left","value","substr","width","getElementById","console","warn","style","transform","scrollLeft","setRange","initialLength","state","start","end","changeHandler","permitNextChange","selectionStart","selectionEnd","dispatchEvent","CustomEvent","detail","isNotWordAfter","trim","previousDetail","mergedEventHandler","events","has","prefix","word","focus","frame","Set","dedup","clear","requestAnimationFrame","type","split","event","which","activeElement","scrollLeftOnBlur","keyCode","v","dedupRenderLine","passive","replaceFocus","call","previousScrollLeft","typer","update","drift","where","arg","[object Object]","modifier.modify","emoji","choice","build","prefixLength","maxSuggestions","prefixSuggest","values","data","k","slice","part","opts","typed","rest","toLowerCase","filter","startsWith","removeDuplicates","row","found","item","merge","existing","lookup","existingRow","updatedData","request","more","Promise","resolve","localPromise","getPrefixGen","then","suggest","url","api","encodeURIComponent","morePromise","fetch","json","both","local","results.merge","refresh","active","adverts","querySelector","nextElementSibling","firstElementChild","enqueue","clearTimeout","timeout","setTimeout","requestIdleCallback","callback","performance","now","fn","bind","didTimeout","timeRemaining","Math","max","cancelIdleCallback","id","Array","prototype","buttons","querySelectorAll","handler","hasValue","Boolean","button","disabled","input","defaultText","spaceRe","copy","_","right","exec","ok","execCommand","e","info","ga","copied","click","canvas","context","getContext","font","cache","count","result","fixedWidthEmoji","navigator","platform","debugMode","location","search","indexOf","emojiWidth","debug","invalidWidth","characterWidth","isExpectedLength","flags","total","expectedLength","ceil","floor","clen","c","list","Map","j","Error","set","get","localStorage","JSON","parse","Date","reject","xhr","XMLHttpRequest","open","onerror","responseType","onload","response","send","loader","stringify","remotePromise","promiseToReturn","select","currentPromise","eventualResolve","pending","runner","body","method","name","predicateTrue","ButtonManager","holder","this","holder_","pendingFirstEmoji_","options_","buttons_","setModifier","genderOption","optionType_","toneOption","createModifierButton","genders","tones","updateStatus","yes","node","owner","l","nextSibling","setAttribute","cand","checker","immediateResult","immediateFirstEmojiForOption_","query","show","qlen","results","options","previousActiveElement","contains","queue","option","option_","delete","button_","async","valid","idle","q","modifier.isExpectedLength","expired","checkFirstEmoji_","spaceFrame","chooser","target","localName","label","b","retainWord","metaKey","ctrlKey","provider.select","arrowKeys","isArrowKey","buttonArray","delta","previousRect","getBoundingClientRect","best","dist","Infinity","targetTop","candidateRect","top","abs","manager","previous","previousQueryAt","pendingFirstEmojiRequest","immediate","provider.request","pow","catch","err","error","invalidLetterRe","simplifyWord","replace","firstEmojiForOption","resize","height","innerHeight","minHeight","serviceWorker","register"],"mappings":"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","file":"bundle.min.js","sourcesContent":["\nconst canvas = document.createElement('canvas');\nconst context = canvas.getContext('2d');\ncontext.font = '1px monospace';\n\n/**\n * @param {string} string to measure\n * @return {number} length of text in monospace units\n */\nconst measureText = (function() {\n  let cache = {};\n  let count = 0;\n\n  return s => {\n    let result = cache[s];\n    if (result === undefined) {\n      cache[s] = result = context.measureText(s).width;\n      if (++count > 4000) {\n        // nb. at June 2017, there's about ~1,800 emojis including variations, so this number is\n        // probably greater than we'll ever use: still, empty if it's too big\n        cache = {};\n        count = 0;\n      }\n    }\n    return result;\n  };\n}());\n\n/**\n * @type {boolean} whether this platform probably has fixed width emoji\n */\nconst fixedWidthEmoji = Boolean(/Mac|Android|iP(hone|od|ad)/.exec(navigator.platform));\n\n/**\n * @param {string} string to measure\n * @return {boolean} whether this is a single char long (and probably a single emoji)\n */\nconst isSingle = (function() {\n  const debugMode = window.location.search.indexOf('debug') !== -1;\n\n  // get a baseline emoji width: this is the well-supported 'FACE WITH TEARS OF JOY'\n  const emojiWidth = measureText('\\u{1f602}');\n  if (fixedWidthEmoji) {\n    if (debugMode) {\n      console.info('fixed emoji width is', emojiWidth, 'for \\u{1f602}');\n      return (s) => {\n        const ok = measureText(s) === emojiWidth;\n        if (!ok) {\n          console.debug('isSingle can\\'t render', s, 'width', measureText(s));\n        }\n        return ok;\n      };\n    }\n    // great! We can quickly check this!\n    return (s) => measureText(s) === emojiWidth;\n  }\n\n  const invalidWidth = context.measureText('\\u{ffffd}').width;\n  const characterWidth = context.measureText('a').width;\n  if (debugMode) {\n    console.info('invalid char has width', invalidWidth, 'ascii char has width', characterWidth);\n  }\n  return (s) => {\n    const width = measureText(s);\n    if (debugMode) {\n      console.debug('isSingle', s, 'has width', width);\n    }\n    return (width !== invalidWidth && width < invalidWidth * 2 && width > characterWidth) ||\n        width === emojiWidth;\n  };\n}());\n\n/**\n * Is this string rendering correctly as an emoji or sequence of emojis? On variable width\n * platforms, this can take O(n).\n *\n * @param {string} string to check\n * @return {boolean} whether this is probably an emoji\n */\nexport const isExpectedLength = (function() {\n  // FIXME: This treats ZWJ'ed characters that aren't a single char as invalid. Maybe it's not\n  // worth worrying, but instead just checking that all the points are valid emoji.\n\n  if (fixedWidthEmoji) {\n    // use 'FACE WITH TEARS OF JOY'\n    const emojiWidth = measureText('\\u{1f602}');\n    return (s) => {\n      // emojis could be _smaller_ than expected, but not larger- and not random non-unit widths\n      const points = jsdecode(s);\n      const chars = splitEmoji(points);\n\n      // count flags, reduce expected by / 2\n      const flags = chars.reduce((total, char) => total += isFlagPoint(char[0].point) ? 1 : 0, 0);\n      const expectedLength = chars.length - Math.ceil(flags / 2);\n\n      const width = measureText(s) / emojiWidth;\n\n      // does this have non-emoji characters in it?\n      if (Math.floor(width) !== width) { return false; }\n\n      // otherwise, as long as we're equal or smaller\n      return width <= expectedLength;\n    };\n  }\n\n  const invalidWidth = context.measureText('\\u{ffffd}').width;\n  return (s) => {\n    const points = jsdecode(s);\n    const chars = splitEmoji(points);\n    const clen = chars.length;\n    for (let i = 0; i < clen; ++i) {\n      const char = chars[i];\n      if (char.length === 0 && isFlagPoint(char[0].point)) {\n        continue;  // treat flag chars as A-OK\n      }\n      // measure this particular point and ensure it's single.\n      const s = String.fromCodePoint(...char.map(c => c.point));\n      if (!isSingle(s)) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n}());\n\n/**\n * True if the standard \"female\" icon can be varied with a diversity modifier. This is the basic\n * level of emoji diversity support, but doesn't imply support for all the professions.\n *\n * @type {boolean}\n */\nconst basicDiversity = (measureText('\\u{1f468}\\u{1f3fb}') === measureText('\\u{1f468}'));\n\n/**\n * @param {number} p\n * @return {boolean} whether the passed rune is a gender character\n */\nfunction isPointGender(p) {\n  return p === 0x2640 || p === 0x2642;\n}\n\n/**\n * @param {number} p\n * @return {boolean} whether the passed rune is a basic emoji person gender: Man or Woman\n */\nfunction isPersonGender(p) {\n  return p === 0x1f468 || p === 0x1f469;\n}\n\n/**\n * @param {number} p\n * @return {boolean} whether this is a subordinate member of a family sequence: boy/girl/baby\n */\nfunction isFamilyMember(p) {\n  return p === 0x1f476 || p === 0x1f466 || p === 0x1f467;\n}\n\n/**\n * @param {number} p\n * @return {boolean} whether the passed rune is a Variation_Selector\n */\nfunction isVariationSelector(p) {\n  return (p >= 0xfe00 && p <= 0xfe0f) || (p >= 0xe0100 && p <= 0xe01ef);\n}\n\n/**\n * @param {number} p\n * @return {boolean} whether the passed rune is a diversity selector (one of five skin tones)\n */\nfunction isDiversitySelector(p) {\n  return p >= 0x1f3fb && p <= 0x1f3ff;\n}\n\n/**\n * @param {number} p\n * @return {boolean} whether the passed rune is one of A-Z for flags\n */\nfunction isFlagPoint(p) {\n  return p >= 0x1f1e6 && p <= 0x1f1ff;\n}\n\n/**\n * @param {number} p\n * @return {boolean} whether the passed rune is probably not a modifier base\n */\nfunction unlikelyModifierBase(p) {\n  return p < 0x261d || isPointGender(p) || isVariationSelector(p) || isDiversitySelector(p) ||\n      isFlagPoint(p);\n}\n\n/**\n * Decodes a JavaScript string into Unicode code points.\n *\n * @param {string} s to decode\n * @return {!Array<number>} code points\n */\nfunction jsdecode(s) {\n  const len = s.length;\n  const points = [];\n\n  for (let i = 0; i < len;) {\n    const raw = s.charCodeAt(i++) || 0;\n    if (raw < 0xd800 || raw > 0xdbff || i === len) {\n      // not a high surrogate, or end of string\n    } else {\n      const extra = s.charCodeAt(i) || 0;\n      if ((extra & 0xfc00) === 0xdc00) {\n        // got a low surrogate, eat 2nd char\n        ++i;\n        points.push(0x10000 + (extra & 0x3ff) + ((raw & 0x3ff) << 10));\n        continue;\n      }\n    }\n    points.push(raw);\n  }\n\n  return points;\n}\n\n/**\n * Returns details about a character and whether it can be gender flipped to a single or neutral\n * gender. This contains emojis which, due to historical emoji reasons, aren't officially versions\n * of each other: e.g., Santa and Mrs. Claus, or Old {Man,Woman,Adult}.\n *\n * @param {number} point to look up in the other gender flips table\n * @return {{single: boolean, neutral: boolean, points: {f: number, m: number, n: number}}?}\n */\nconst genderFlip = (function() {\n  // TODO: covers F/M/neutral, but _not_ mixed (e.g. holding hands => no m/f combo)\n  const list = [\n    0x1f936, 0x1f385, 0,        // mrs. claus, santa\n    0x1f483, 0x1f57a, 0,        // dancers\n    0x1f470, 0x1f935, 0,        // bride, man in tuxedo\n    0x1f467, 0x1f466, 0,        // girl, boy\n    0x1f475, 0x1f474, 0x1f9d3,  // old {woman,man,adult}\n    0x1f46d, 0x1f46c, 0,        // women/men holding hands\n    0x1f478, 0x1f934, 0,        // princess, prince\n  ];\n\n  // build map with raw data only\n  const all = new Map();\n  for (let i = 0; i < list.length; i += 3) {\n    const data = {\n      points: {f: list[i], m: list[i+1], n: list[i+2]},\n    };\n    for (let j = 0; j < 3; ++j) {\n      const v = list[i+j];\n      if (v) {\n        if (all.has(v)) {\n          throw new Error('duplicate in gender list: ' + v);\n        }\n        all.set(v, data);\n      }\n    }\n  }\n\n  // return helper\n  return point => {\n    const out = all.get(point) || null;\n    if (out && out.single === undefined) {\n      // do the heavy lifting only when first fetched\n      out.single = isSingle(String.fromCodePoint(out.points.f)) &&\n          isSingle(String.fromCodePoint(out.points.m));\n      out.neutral = out.points.n && isSingle(String.fromCodePoint(out.points.n));\n    }\n    return out;\n  };\n}());\n\n/**\n * Splits a single emoji into raw characters, removing variants or diversity modifiers. Each\n * sub-array represents a character previously split by ZWJs.\n *\n * @param {!Array<number>} points\n * @return {!Array<!Array<{point: number, suffix: number}>>}\n */\nfunction splitEmoji(points) {\n  if (!points.length) {\n    return [];\n  }\n  let curr = [{point: points[0], suffix: 0}];\n  const out = [curr];\n\n  // TODO: doesn't deal with flags or regional letters\n  // flags are weird: U + N + A, for instance, will render the Namibia flag where the UN flag is\n  // not supported (but the UN flag where it is)- taking the left-most valid code\n  // NOTE: the regional flag letters are seen as _emoji_ on their own, at least on Mac.\n\n  for (let i = 1; i < points.length; ++i) {\n    const check = points[i];\n\n    if (isFlagPoint(curr[curr.length-1].point)) {\n      // previous was a flag, create a new one\n    } else if (isDiversitySelector(check) || isVariationSelector(check)) {\n      // store in suffix\n      curr[curr.length-1].suffix = check;\n      continue;\n    } else if (check === 0x200d) {\n      // push next char onto curr\n      const next = points[++i];\n      next && curr.push({point: next, suffix: 0});\n      continue;\n    }\n\n    // new character, reset\n    curr = [{point: check, suffix: 0}];\n    out.push(curr);\n  }\n  return out;\n}\n\n/**\n * Analyses or modifes an emoji string for modifier support: diversity and gender.\n *\n * This might be O(n), including the cost of measuring every individual character via measureText.\n *\n * @param {string} s\n * @param {{tone: undefined|number, gender: undefined|string}=} opt_op\n * @return {out: (string|undefined), tone: boolean, gender: {single: boolean, double: boolean, neutral: boolean}}\n */\nexport function modify(s, opt_op) {\n  const stats = {tone: false, gender: {single: false, double: false, neutral: false}};\n  if (!s) {\n    return stats;\n  }\n  const points = jsdecode(s);\n\n  // split out gender modifiers and other variations with splitEmoji, walk chars\n  const chars = splitEmoji(points);\n  const record = (opt_op ? [] : null);\n  chars.some((char, i) => {\n    const first = char[0].point;\n    let genderable = 0;\n    let family = false;\n\n    // search for existing gender characters\n    char.forEach(ch => {\n      const p = ch.point;\n      if (isPointGender(p)) {\n        // we can remove or replace the point\n        stats.gender.single = true;\n        stats.gender.neutral = true;\n      } else if (isPersonGender(p)) {\n        // easily swappable person\n        stats.gender.single = true;\n        if (++genderable >= 2) {\n          stats.gender.double = true;\n        }\n      } else if (isFamilyMember(p) && genderable) {\n        // this run is a family (child and already has parent), so it can't be made diverse\n        family = true;\n      } else {\n        // look for potential gender flips\n        const flip = genderFlip(p);\n        if (flip) {\n          stats.gender.single |= flip.single;\n          stats.gender.neutral |= flip.neutral;\n        }\n      }\n    });\n\n    // check for professions ('non family person'): single initial person gender, not a family\n    const isSinglePerson =\n        genderable ? (isPersonGender(first) && genderable === 1 && !family) : undefined;\n    if (isSinglePerson) {\n      stats.tone = basicDiversity;\n    }\n    if (record) {\n      // true: is a 'non family person', aka profession or disembodied head (diversity OK)\n      // false: is a family or other combined group of persons (no diversity)\n      // undefined: something else\n      record[i] = isSinglePerson;\n    }\n\n    // check for early exhaustive answer\n    if ((stats.tone || !basicDiversity) && stats.gender.neutral) {\n      // ... don't finish 'some' early if we're recording gender data\n      return !record && stats.gender.single && stats.gender.double;\n    }\n\n    // skip if profession, low emojis (everything below Emoji_Modifier_Base) and male/female signs\n    if (isSinglePerson === false || unlikelyModifierBase(first)) { return; }\n\n    // do slow measure checks\n    // TODO: can we use \\p{Modifier_Base} as a faster check than measureText for +ve case?\n    const candidate = String.fromCodePoint(first);\n    if (basicDiversity && !stats.tone && isSingle(candidate + '\\u{1f3fb}')) {\n      stats.tone = true;\n    }\n    if (!stats.gender.neutral && isSingle(candidate + '\\u{200d}\\u{2640}\\u{fe0f}')) {\n      stats.gender.neutral = true;\n      stats.gender.single = true;\n    }\n  });\n\n  // early out without op\n  if (!opt_op) {\n    return stats;\n  }\n\n  // gender helper: modifies passed character to apply next gender (or returns new ch)\n  const nextGenderPoint = (function() {\n    const g = opt_op.gender || '';\n    let previousMaster;\n    let index;\n    return (master, opt_point, opt_allowOtherFlip) => {\n      if (previousMaster === undefined || master !== previousMaster) {\n        previousMaster = master;\n        index = 0;\n      } else {\n        ++index;\n      }\n      const next = g ? g[index % g.length] : '';\n      const point = opt_point || 0;\n      if (isPersonGender(point)) {\n        // if this is a person, return the alternative person (or make no change)\n        return next ? (next === 'm' ? 0x1f468 : 0x1f469) : point;\n      } else if (!point || isPointGender(point)) {\n        // if this is a point, return the alternative point (or clear)\n        return next ? (next === 'm' ? 0x2642 : 0x2640) : 0;\n      } else if (opt_allowOtherFlip) {\n        // do other gender flips: note that some of these have F/M/N, but not all have N\n        const flip = genderFlip(point);\n        if (flip) {\n          if (!next && flip.neutral) {\n            return flip.points.n;\n          } else if (next && flip.single) {\n            return next === 'm' ? flip.points.m : flip.points.f;\n          }\n        }\n      }\n      // didn't consume anything\n      --index;\n      return point;\n    };\n  }());\n\n  // walk over all chars, apply change\n  const out = chars.map((char, i) => {\n    const points = [];  // used as nonce, declare first\n    const isSinglePerson = record[i];\n    const first = char[0].point;\n\n    if (opt_op.gender !== undefined) {\n      // replace/remove existing male/female characters\n      // nb. this removes orphaned gender point characters\n      const allowOtherFlip = (isSinglePerson === undefined);  // not for family/profession\n      char.forEach(ch => ch.point = nextGenderPoint(points, ch.point, allowOtherFlip));\n\n      // under various conditions, add a gender modifier to a single point\n      if (isSinglePerson === undefined && char.length === 1 && !isPointGender(first)) {\n        const genderPoint = nextGenderPoint(points);\n        if (genderPoint && isSingle(String.fromCodePoint(first) + '\\u{200d}\\u{2640}\\u{fe0f}')) {\n          char.push({suffix: 0xfe0f, point: genderPoint});\n        }\n      }\n    }\n\n    // apply diversity\n    if (opt_op.tone !== undefined) {\n      char.forEach((ch, i) => {\n        if (isDiversitySelector(ch.suffix)) {\n          // always tweak existing diversity modifiers\n          ch.suffix = opt_op.tone;\n        } else if (i === 0 && basicDiversity && isSinglePerson !== false) {\n          // if it's the first point in a non-family, try to apply diversity\n          if (isSinglePerson || isSingle(String.fromCodePoint(first) + '\\u{1f3fb}')) {\n            ch.suffix = opt_op.tone;\n          }\n        }\n      });\n    }\n\n    // flatten into actual codepoints again\n    char.forEach(ch => {\n      if (ch.point) {\n        points.length && points.push(0x200d);\n        points.push(ch.point);\n        ch.suffix && points.push(ch.suffix);\n      }\n    });\n    return points;\n  }).reduce((all, points) => all.concat(points), []);\n\n  stats.out = String.fromCodePoint(...out);\n  return stats;\n};\n","\nimport * as modifier from './lib/modifier.js';\n\nfunction datasetSafeDelete(el, ...keys) {\n  const d = el.dataset;\n  keys.forEach((key) => {\n    if (key in d) {\n      delete d[key];\n    }\n  });\n}\n\n// word focus handler\nfunction upgrade(el) {\n  const isWordCode = (code) => {\n    // FIXME: turns out matching non-emoji is hard\n    // TODO: this RegExp _might_ work but it needs transpiling-\n    // new RegExp(/(?:[\\p{Letter}\\p{Number}\\p{Punctuation}](?!\\u{fe0f}?\\u{20e3}))+/u);\n    return code < 5000 && code != 32;\n  };\n\n  const helper = document.createElement('div');\n  helper.className = 'overflow-helper';\n  el.parentNode.insertBefore(helper, el);\n\n  const underline = document.createElement('div');\n  underline.className = 'underline';\n  helper.appendChild(underline);\n\n  // measures the width of text\n  const measureText = (function() {\n    const sizer = document.createElement('div');\n    sizer.className = 'sizer';\n    helper.appendChild(sizer);\n\n    const nonce = document.createElement('div');\n    nonce.className = 'nonce';\n\n    return (text) => {\n      sizer.textContent = text;\n      sizer.appendChild(nonce);\n      return nonce.offsetLeft;\n    }\n  }());\n\n  // hide underline until load: the font used might not be ready, so it's probably out of whack\n  if (document.readyState !== 'complete') {\n    underline.classList.add('loading');\n    window.addEventListener('load', (ev) => {\n      renderLine();\n      underline.classList.remove('loading');\n    });\n  }\n\n  const renderLine = () => {\n    if (el.dataset.from === undefined) {\n      underline.hidden = true;\n      return false;\n    }\n    const [from, to] = [+el.dataset.from, +el.dataset.to];\n\n    // otherwise, record and draw the line\n    const left = measureText(el.value.substr(0, from));\n    const width = measureText(el.value.substr(from, to - from));\n\n    if (width < 0 && !document.getElementById('less')) {\n      // nb. this seems to happen in dev with lesscss\n      console.warn('invalid sizer width', width, 'for text', sizer.textContent);\n    }\n\n    underline.hidden = width <= 0;\n    underline.style.left = left + 'px';\n    underline.style.width = width + 'px';\n    underline.style.transform = 'translateX(-' + el.scrollLeft + 'px)';\n  };\n\n  // force selection\n  const setRange = (from, to) => {\n    if (from >= to) {\n      datasetSafeDelete(el, 'from', 'to', 'prefix', 'word', 'focus');\n      underline.hidden = true;\n      return false;\n    }\n    [el.dataset.from, el.dataset.to] = [from, to];\n    el.dataset['focus'] = el.value.substr(from, to - from);\n    renderLine();\n    return true;\n  };\n\n  // state/handler keep track of the current focus word (plus scroll position, if input is big)\n  const initialLength = el.value.length;\n  const state = {start: initialLength, end: initialLength, value: undefined};\n  const changeHandler = (permitNextChange) => {\n    if (permitNextChange !== false &&\n        el.selectionStart === state.start &&\n        el.selectionEnd === state.end &&\n        el.value === state.value) {\n      return true;  // already at this state\n    }\n    [state.start, state.end] = [el.selectionStart, el.selectionEnd];\n    if (state.value !== el.value) {\n      el.dispatchEvent(new CustomEvent('value', {detail: el.value}));\n      state.value = el.value;\n    }\n\n    // range selection, magic\n    if (state.start !== state.end) {\n      datasetSafeDelete(el, 'prefix', 'word');\n\n      setRange(state.start, state.end);\n\n      underline.classList.add('range');\n      el.classList.add('range');\n      return false;\n    }\n    underline.classList.remove('range');\n    el.classList.remove('range');\n\n    // calculate from/to locally\n    let from = state.start;\n    let to = state.start;\n\n    // are we at the end (only have spaces until end)?\n    const isAtEnd = !el.value.substr(state.end).trim();\n    const isNotWordAfter = isAtEnd || !isWordCode(el.value.charCodeAt(state.end));\n\n    if (isNotWordAfter) {\n      for (; to > 0; --to) {\n        if (el.value.charCodeAt(to - 1) !== 32) {\n          break;\n        }\n      }\n      if (to < from) {\n        from = to;\n      }\n    }\n\n    // walk backwards while the previous character is a word\n    for (; from > 0; --from) {\n      if (!isWordCode(el.value.charCodeAt(from - 1))) {\n        break;\n      }\n    }\n\n    // walk forwards while the next char is not a space\n    for (; to < el.value.length; ++to) {\n      if (!isWordCode(el.value.charCodeAt(to))) {\n        break;\n      }\n    }\n\n    // if it's invalid, but there's not a word after, and we were permitted, ignore\n    if (from >= to && isNotWordAfter && permitNextChange) { return; }\n    if (setRange(from, to)) {\n      // if the range was valid, update the prefix/focus but delete the word (in typing state)\n      el.dataset['focus'] = el.dataset['prefix'] = el.value.substr(from, to - from);\n      datasetSafeDelete(el, 'word');\n    }\n  };\n\n  // runs change handler and emits the 'word' event as appropriate\n  let previousDetail = {};\n  const mergedEventHandler = (events, permitNextChange) => {\n    // if there was a focus event, don't let the browser take over: reset previous known good\n    if (events.has('focus')) {\n      // only if it wasn't a range selection (otherwise clicking back retains range, weird)\n      if (state.start === state.end) {\n        // TODO: this sets on initial load, even though it probably doesn't need to\n        [el.selectionStart, el.selectionEnd] = [state.start, state.end];\n      }\n    }\n\n    // run change handler: if true, nothing changed\n    if (changeHandler(permitNextChange)) { return; }\n\n    // send query: prefix or whole-word\n    const text = el.dataset.prefix || el.dataset.word || null;\n    const detail = {text, prefix: 'prefix' in el.dataset, focus: el.dataset.focus};\n\n    // send event only if something has changed\n    if (detail.text !== previousDetail.text ||\n        detail.prefix !== previousDetail.prefix ||\n        detail.focus !== previousDetail.focus) {\n      previousDetail = detail;\n      el.dispatchEvent(new CustomEvent('query', {detail}));\n    }\n  };\n\n  // dedup listeners on a rAF\n  let permitNextChange;  // FIXME: global-ish scope is ugly\n  (function() {\n    let frame;\n    let events = new Set();  // records the events that occured to cause this\n    const dedup = (ev) => {\n      if (!frame) {\n        permitNextChange = undefined;\n        events.clear();\n        frame = window.requestAnimationFrame(() => {\n          frame = null;\n          mergedEventHandler(events, permitNextChange);\n        });\n      }\n      ev && events.add(ev.type);\n    };\n\n    // lots of listeners for a million different change reasons\n    const rest = 'change keydown keypress focus click mousedown select input';\n    rest.split(/\\s+/).forEach((event) => el.addEventListener(event, dedup));\n    dedup();\n\n    // if a user is dragging around, this might be changing the offsetLeft (dragging input l/r)\n    el.addEventListener('mousemove', (ev) => {\n      if (ev.which) {\n        dedup();\n      }\n    });\n\n    // add 'selectionchange' (only valid on document) to listen to the initial long-press selection\n    // on Chrome (possibly others?) mobile: it doesn't generate 'select'.\n    document.addEventListener('selectionchange', (ev) => {\n      if (document.activeElement === el) {\n        dedup();\n      }\n    });\n\n    // on blur, after a backspace, Chrome moves the start/end selection: fix it\n    let scrollLeftOnBlur = false;\n    el.addEventListener('blur', (ev) => {\n      if (el.scrollLeft) {\n        scrollLeftOnBlur = el.scrollLeft || false;\n      }\n      if (el.selectionStart !== state.start || el.selectionStart !== state.end) {\n        [el.selectionStart, el.selectionEnd] = [state.start, state.end];\n      }\n    }, true);\n    el.addEventListener('focusout', (ev) => {\n      if (scrollLeftOnBlur !== false) {\n        el.scrollLeft = scrollLeftOnBlur;\n        scrollLeftOnBlur = false;\n      }\n    }, true);\n  }());\n\n  // add a non-deduped keydown handler, to run before others and intercept space\n  el.addEventListener('keydown', (ev) => {\n    switch (ev.key) {\n    case 'Escape':\n      permitNextChange = false;  // force next change\n      break;\n\n    case ' ':\n      if (el.dataset.prefix && el.selectionStart === +el.dataset.to) {\n        el.dispatchEvent(new CustomEvent('request', {detail: el.dataset.prefix}));\n      }\n\n      // TODO: do this to prevent actually space being hit (@samthor prefers it this way)\n      //ev.preventDefault();\n      break;\n    }\n  });\n\n  // add a non-deduped keyup handler, for space on mobile browsers\n  el.addEventListener('keyup', (ev) => {\n    if (ev.keyCode === 229 || !ev.keyCode) {\n      // look for a space before whatever was entered.\n      const v = el.value.substr(el.selectionStart - 1, 1);\n      if (v === ' ' && el.dataset.prefix) {\n        el.dispatchEvent(new CustomEvent('request', {detail: el.dataset.prefix}));\n      }\n    }\n  });\n\n  // dedup re-rendering calls\n  (function() {\n    let frame;\n    const dedupRenderLine = () => {\n      if (!frame) {\n        frame = window.requestAnimationFrame(() => {\n          frame = null;\n          renderLine();\n        });\n      }\n    };\n    window.addEventListener('resize', dedupRenderLine);\n    el.addEventListener('wheel', dedupRenderLine, {passive: true});\n  }());\n\n  // replace helper\n  const replaceFocus = (call) => {\n    if (el.dataset.from === undefined || el.dataset.to === undefined) { return false; }\n\n    const previousScrollLeft = el.scrollLeft;\n    const [from, to] = [+el.dataset.from, +el.dataset.to];\n    const value = el.value.substr(from, to - from);\n    let [start, end] = [typer.selectionStart, typer.selectionEnd];\n\n    const update = call(value);\n    if (update == null) { return false; }\n    typer.value = typer.value.substr(0, from) + update + typer.value.substr(to);\n\n    const drift = (where) => {\n      if (where > to) {\n        // after the update\n        where = where - (to - from) + update.length;\n      } else if (where > from) {\n        // during the update\n        where = from + update.length;\n      } else {\n        // do nothing, was before\n      }\n      return where;\n    };\n\n    typer.focus();\n    typer.dispatchEvent(new CustomEvent('change'));  // nb. updates from/to (from won't change)\n    // pretend we were like this all along\n    [state.start, state.end] = [typer.selectionStart, typer.selectionEnd] = [drift(start), drift(end)];\n\n    permitNextChange = true;\n    el.scrollLeft = previousScrollLeft;  // before setRange, so the underline is correct\n    setRange(from, from + update.length);\n    return true;\n  };\n\n  // handle 'modifier' event: apply modifiers to the focus word, if any\n  el.addEventListener('modifier', (ev) => {\n    const arg = {[ev.detail.type]: ev.detail.code};\n    replaceFocus((value) => modifier.modify(value, arg).out || '');\n  });\n\n  // handle 'emoji' event: if there's a current focus word, then replace it with the new emoji \\o/\n  el.addEventListener('emoji', (ev) => {\n    const emoji = ev.detail.choice;\n    if (!replaceFocus(() => emoji)) { return; }\n\n    // listen to the caller's view on what word we should pretend this emoji is\n    el.dataset['word'] = ev.detail.word || '';\n    datasetSafeDelete(el, 'prefix');\n  });\n}\n\nupgrade(typer);\n","\nexport default function build(raw, prefixLength=3, maxSuggestions=10) {\n  const prefixSuggest = {};\n\n  const values = {};\n  raw.forEach(data => {\n    const k = data[0];\n    values[k] = data.slice(1);\n\n    const prefix = k.substr(0, prefixLength);\n    for (let i = 1; i <= prefix.length; ++i) {\n      const part = prefix.substr(0, i);\n      let opts = prefixSuggest[part];\n      if (!opts) {\n        opts = prefixSuggest[part] = [];\n      }\n      if (opts.length < maxSuggestions) {\n        opts.push(k);\n      }\n    }\n  });\n\n  return function(typed, prefix) {\n    typed = typed.toLowerCase();\n    const rest = typed.substr(prefixLength);\n    let all = prefixSuggest[typed.substr(0, prefixLength)] || [];\n\n    if (rest) {\n      all = all.filter(word => word.substr(prefixLength).startsWith(rest));\n    }\n    if (!prefix) {\n      all = all.filter(word => word === typed);\n    }\n    all = all.map(word => [word, ...values[word]]);\n\n    return all.length ? all : [];\n  }\n}\n","\n/**\n * Remove duplicate entries from the passed array, only from the 1th index.\n *\n * @param {!Array<string>}\n * @return {!Array<string>}\n */\nfunction removeDuplicates(row) {\n  const found = new Set();\n  return row.filter((item, i) => {\n    if (i !== 0) {\n      if (found.has(item)) { return false; }\n      found.add(item);\n    }\n    return true;\n  });\n}\n\n/**\n * Merge the given results arrays. These will both be in the form of:\n *   [[name, emoji1, emoji2,....], ...]\n *\n * The first argument will be updated with the data from the second argument.\n *\n * @param {!Array<!Array<string>>} existing\n * @param {!Array<!Array<string>>} update\n */\nexport function merge(existing, update) {\n  const lookup = {};\n  existing.forEach((row, i) => lookup[row[0]] = i);\n\n  update.forEach((row) => {\n    const index = lookup[row[0]];\n    if (index === undefined) {\n      lookup[row[0]] = existing.length;  // in case there's dup data\n      existing.push(row);\n      return;\n    }\n\n    // otherwise, just append all new data and place back into array\n    const existingRow = existing[index];\n    const updatedData = row.slice(1);\n    existing[index] = removeDuplicates(existingRow.concat(updatedData));\n  });\n}","const api = 'https://us-central1-emojityper.cloudfunctions.net';\n\nimport build from './prefixgen.js';\nimport * as results from './results.js';\n\n/**\n * Returns the local prefix search tool.\n *\n * @return {function(string, boolean): !Array<!Array<string>>}\n */\nconst getPrefixGen = (function() {\n  let localPromise = null;  // results from localStorage\n  const raw = window.localStorage['popular'];\n  if (raw) {\n    let out;\n    try {\n      out = JSON.parse(raw);\n    } catch (e) {\n      console.debug('couldn\\'t parse localStorage popular', e);\n      out = null;\n    }\n    if (out) {\n      localPromise = Promise.resolve(build(out['results']));\n      if (out['created'] >= (+new Date - 60 * 60 * 24 * 1000)) {\n        // return immediately, it's less than one day old\n        return () => localPromise;\n      }\n    }\n  }\n\n  // we don't have data or it's >1day old, refetch\n  const f = new Promise((resolve, reject) => {\n    const xhr = new XMLHttpRequest();\n    xhr.open('GET', api + '/popular');\n    xhr.onerror = reject;\n    xhr.responseType = 'json';\n    xhr.onload = () => resolve(xhr.response);\n    xhr.send();\n  }).then(raw => {\n    // IE11 doesn't respect responseType, and we always return an Object\n    return typeof raw === 'string' ? JSON.parse(raw) : raw;\n  });\n\n  f.then(data => {\n    // TODO: It's a bit ugly to hit the loader from here.\n    window.loader.hidden = true;\n    data['created'] = +new Date();\n    window.localStorage['popular'] = JSON.stringify(data);\n  });\n\n  const remotePromise = f.then(v => build(v['results']));\n  if (!localPromise) {\n    // TODO: It's a bit ugly to hit the loader from here.\n    window.loader.hidden = false;\n    return () => remotePromise;  // wait for data\n  }\n\n  // return localPromise until remotePromise is done\n  let promiseToReturn = localPromise;\n  remotePromise.then(() => promiseToReturn = remotePromise);\n  return () => promiseToReturn;\n}());\n\n/**\n * Requests emoji completion.\n *\n * @param {string} text user has typed\n * @param {boolean} prefix is this a prefix search, or is it a definite whole word?\n * @param {boolean=} more whether to return lots more results for this query\n * @return {!Promise<!Array<!Array>>}\n */\nexport function request(text, prefix, more=false) {\n  if (!text) {\n    return Promise.resolve([]);\n  }\n\n  const localPromise = getPrefixGen().then(suggest => suggest(text, prefix));\n  if (!more) {\n    return localPromise;\n  }\n\n  // TODO: At some point, the 'more' data should go into a local cache. For now, just fetch.\n  let url = `${api}/query?query=${window.encodeURIComponent(text)}`;\n  if (prefix) {\n    url += '&prefix=true';\n  }\n  const morePromise = window.fetch(url).then(out => out.json()).then(out => out['results']);\n  return Promise.all([localPromise, morePromise]).then(both => {\n    const [local, more] = both;\n    results.merge(local, more);\n    return local;\n  });\n}\n\n/**\n * Records use of name/emoji pairs.\n *\n * @param {string} name used to select emoji\n * @param {string} emoji selected\n * @param {!Promise<!Response>} eventual response after delay\n */\nexport const select = (function() {\n  const delay = 5 * 1000;\n  let pending = {};\n  let timeout;\n  let currentPromise;\n  let eventualResolve;\n\n  const runner = () => {\n    const body = JSON.stringify(pending);\n    pending = {};  // clear pending for next time\n\n    // TODO: use sendBeacon\n    const p = window.fetch(api + '/select', {method: 'POST', body})\n    if (!eventualResolve) {\n      throw new Error('got fetch without eventualResolve');\n    }\n    currentPromise = null;  // success... probably\n    eventualResolve(p);\n  };\n\n  return function select(name, emoji) {\n    pending[name] = emoji;\n\n    if (!currentPromise) {\n      // save resolve for later\n      currentPromise = new Promise((resolve) => eventualResolve = resolve);\n    }\n\n    window.clearTimeout(timeout);\n    timeout = window.setTimeout(runner, delay);\n    return currentPromise;\n  }\n}());\n\n/**\n * Submit the name of an emoji.\n *\n * @param {string} name\n * @param {string} emoji\n * @return {!Promise<Response>}\n */\nexport function submit(name, emoji) {\n  const body = new FormData();\n  body.append('name', name);\n  body.append('emoji', emoji);\n  return window.fetch(api + '/name', {method: 'POST', mode: 'cors', body});\n}\n","\nconst adverts = document.getElementById('adverts');\n\nfunction refresh() {\n  const active = adverts.querySelector('.active');\n  const next = (active && active.nextElementSibling || adverts.firstElementChild);\n  if (!next) {\n    console.warn('no adverts to choose from');\n    return;\n  }\n\n  active && active.classList.remove('active');\n  next.classList.add('active');\n\n  enqueue();\n}\n\nlet timeout;\nfunction enqueue() {\n  window.clearTimeout(timeout);\n  timeout = window.setTimeout(() => {\n    window.requestAnimationFrame(refresh);\n  }, 10 * 1000);\n}\n\nenqueue();\n","\n/**\n * @fileoverview Polyfills needed for modern browsers, even those supporting ES6 modules.\n */\n\nif (!window.requestIdleCallback) {\n  // TODO: this is a pretty terrible requestIdleCallback\n  window.requestIdleCallback = (callback) => {\n    const start = performance.now();\n    const fn = callback.bind(null, {\n      didTimeout: false,\n      timeRemaining: () => Math.max(0, 50 - (performance.now() - start)),\n    });\n    return window.setTimeout(fn, 1);\n  };\n\n  window.cancelIdleCallback = id => window.clearTimeout(id);\n}\n\n","\nconst all = Array.prototype.slice.call(buttons.querySelectorAll('button'));\n\nconst handler = ev => {\n  const text = ev.detail.trim();\n  const hasValue = Boolean(text);\n  all.forEach(button => button.disabled = !hasValue);\n};\ntyper.addEventListener('value', handler);\nhandler({detail: typer.value});\n\n// copy handler\n(function(button, input) {\n  let timeout;\n  const defaultText = button.textContent;\n  const spaceRe = /\\s*/;\n\n  const copy = _ => {\n    const [start, end] = [input.selectionStart, input.selectionEnd];\n\n    // find start/end of content (trim, but find positions)\n    let left = 0;\n    let right = input.value.length;\n    if (input.selectionStart !== input.selectionEnd) {\n      left = input.selectionStart;\n      right = input.selectionEnd;\n    }\n    left += spaceRe.exec(input.value.substr(left))[0].length;\n    right = left + input.value.substr(left, right - left).trim().length;\n    if (right <= left) { return false; }\n\n    input.focus();\n    input.selectionStart = left;\n    input.selectionEnd = right;\n\n    let ok = false;\n    try {\n      ok = document.execCommand('copy');\n    } catch(e) {\n      console.warn('could not copy', e);\n      ok = false;\n    }\n    // restore previous selection\n    [input.selectionStart, input.selectionEnd] = [start, end];\n\n    if (!ok) { return true; }\n    console.info('copied', input.value.substr(left, right));\n\n    // analytics\n    ga('send', 'event', 'text', 'copy');\n\n    // show message\n    button.textContent = button.dataset.copied;\n    window.clearTimeout(timeout);\n    timeout = window.setTimeout(ev => {\n      button.textContent = defaultText;\n    }, 500);\n  };\n\n  input.addEventListener('keydown', ev => {\n    if (ev.key == 'Enter') {\n      button.click();\n      input.focus();\n    }\n  });\n  button.addEventListener('click', ev => {\n    copy();\n    button.focus();\n  });\n}(copy, typer));\n\n","\n// suggestion handler\n\nimport * as provider from './lib/provider.js';\nimport * as modifier from './lib/modifier.js';\n\nconst predicateTrue = () => true;\n\n/**\n * ButtonManager helps create and show emoji buttons in the UI.\n */\nclass ButtonManager {\n  constructor(holder) {\n    this.holder_ = holder;\n    this.pendingFirstEmoji_ = null;\n\n    /** @type {!Map<string, !HTMLElement>} */\n    this.options_ = new Map();\n\n    /** @type {!Map<string, !HTMLButtonElement>} */\n    this.buttons_ = new Map();\n\n    /** @type {function(this:ButtonManager, !Object): void} */\n    this.setModifier = (() => {\n      const genderOption = ButtonManager.optionType_('modifier', 'gender');\n      const toneOption = ButtonManager.optionType_('modifier', 'tone');\n      this.holder_.appendChild(genderOption);\n      this.holder_.appendChild(toneOption);\n\n      // helper to create buttons\n      const createModifierButton = (text, value=null) => {\n        const button = document.createElement('button');\n        button.textContent = text;\n        button.dataset['value'] = value;\n        return button;\n      };\n\n      // create gender options\n      const genders = [\n        createModifierButton('\\u{2014}', ''),\n        createModifierButton('\\u{2640}', 'f'),\n        createModifierButton('\\u{2640}\\u{2642}', 'fm'),\n        createModifierButton('\\u{2642}', 'm'),\n        createModifierButton('\\u{2642}\\u{2640}', 'mf'),\n      ];\n\n      // create tone options\n      const tones = [\n        toneOption.appendChild(createModifierButton('\\u{2014}', '')),\n      ];\n      for (let i = 0x1f3fb; i <= 0x1f3ff; ++i) {\n        tones.push(createModifierButton(String.fromCodePoint(i), i));\n      }\n\n      // helper to add/remove\n      const updateStatus = (yes, node, owner) => {\n        yes ? owner.appendChild(node) : node.remove();\n      };\n      return function(info) {\n        genders.forEach(node => {\n          const l = node.dataset['value'].length;\n          const yes = (!l && info.gender.neutral)\n              || (l === 1 && info.gender.single)\n              || (l === 2 && info.gender.double);\n          updateStatus(yes, node, genderOption);\n        });\n        tones.forEach(node => updateStatus(info.tone, node, toneOption));\n\n        // kick the elements: Safari needs this otherwise sometimes they remain hidden (!)\n        this.holder_.insertBefore(genderOption, genderOption.nextSibling);\n        this.holder_.insertBefore(toneOption, toneOption.nextSibling);\n      }\n    })();\n  }\n\n  static optionType_(type, value) {\n    const node = document.createElement('div');\n    node.className = 'options ' + type;\n    node.setAttribute('data-' + type, value);\n    return node;\n  }\n\n  static option_(name) {\n    const node = document.createElement('div');\n    node.className = 'options';\n    node.setAttribute('data-name', name);\n    return node;\n  }\n\n  static button_(text) {\n    const button = document.createElement('button');\n    button.className = 'unknown';\n    button.textContent = text;\n    return button;\n  }\n\n  immediateFirstEmojiForOption_(name) {\n    const node = this.options_.get(name);\n    if (!node) { return null; }\n\n    let cand = node.firstElementChild;\n    while (cand) {\n      if (!cand.hidden && cand.className === '') {\n        return cand.textContent;\n      }\n      cand = cand.nextElementSibling;\n    }\n    return null;\n  }\n\n  checkFirstEmoji_() {\n    this.pendingFirstEmoji_ && this.pendingFirstEmoji_();\n  }\n\n  /**\n   * Returns a promise for the first valid emoji value for the given name. This allows a user to\n   * keep typing(-ish) yet have their text replaced with emoji.\n   *\n   * This promise isn't guaranteed to resolve. Drops previous request on additional calls.\n   *\n   * @param {string} name to search for\n   * @return {!Promise<?string>} emoji found\n   */\n  firstEmojiForOption(name) {\n    if (!name) {\n      return Promise.resolve(null);\n    }\n    return new Promise((resolve) => {\n      const checker = () => {\n        const immediateResult = this.immediateFirstEmojiForOption_(name);\n        if (!immediateResult) {\n          return false;\n        }\n        if (this.pendingFirstEmoji_ === checker) {\n          this.pendingFirstEmoji_ = null;\n        }\n        resolve(immediateResult);\n      };\n      this.pendingFirstEmoji_ = checker;\n      checker();\n    });\n  }\n\n  /**\n   * Filters all local option nodes based on the given query.\n   *\n   * @param {string} query\n   * @param {boolean} prefix\n   */\n  localFilter(query, prefix) {\n    let show = predicateTrue;\n    if (prefix === true) {\n      const qlen = query.length;\n      if (qlen !== 0) {\n        show = (name) => name.length >= qlen && name.substr(0, qlen) === query;\n      }\n    } else {\n      show = (name) => (name === query);\n    }\n    this.options_.forEach((node, name) => node.hidden = !show(name));\n  }\n\n  /**\n   * Updated displayed options with real results. Adds all nodes immediately, but returns a Promise\n   * which indicates when all valid emoji are shown.\n   *\n   * @param {!Array<!Array<string>>}\n   * @return {!Promise<undefined>}\n   */\n  update(results) {\n    const options = new Map();\n    const buttons = new Map();\n    const previousActiveElement =\n        this.holder_.contains(document.activeElement) ? document.activeElement : null;\n    const queue = [];\n\n    results.forEach(result => {\n      const name = result[0];\n\n      const option = this.options_.get(name) || ButtonManager.option_(name);\n      this.options_.delete(name);\n      options.set(name, option);\n      option.hidden = true;\n      this.holder_.appendChild(option);  // reinsert in better order\n\n      for (let i = 1, emoji; emoji = result[i]; ++i) {\n        if (buttons.has(emoji)) {\n          continue;  // already stolen by something above us\n        }\n\n        let button = this.buttons_.get(emoji);\n        if (!button) {\n          button = ButtonManager.button_(emoji);\n          queue.push({emoji, button});\n        } else {\n          this.buttons_.delete(emoji);\n          if (!button.className) {\n            // if it's still unknown, option stays hidden\n            option.hidden = false;\n          }\n        }\n        buttons.set(emoji, button);\n        option.appendChild(button);\n      }\n    });\n\n    this.options_.forEach((option) => option.remove());\n    this.buttons_.forEach((button) => button.remove());\n    this.options_ = options;\n    this.buttons_ = buttons;\n\n    if (previousActiveElement) {\n      if (!previousActiveElement.parentNode) {\n        typer.focus();  // restore to main input\n      } else {\n        previousActiveElement.focus();\n      }\n    }\n\n    // TODO: move this to be running \"all the time\"\n    // nb. This is a function as Safari fails on async arrows:\n    // https://bugs.webkit.org/show_bug.cgi?id=166879\n    return (async function() {\n      let valid = 0;\n      let idle = null;\n      const start = window.performance.now();\n\n      // don't start with idle: the first N might complete really fast (already known)\n      for (let q = 0; q < queue.length; ++q) {\n        const {emoji, button} = queue[q];\n        if (!button.parentNode) {\n          continue;\n        }\n        if (modifier.isExpectedLength(emoji)) {\n          button.className = '';\n          button.parentNode.hidden = false;\n          ++valid;\n        } else {\n          button.remove();\n        }\n\n        if (q < 20 || (idle === null && window.performance.now() - start < 10)) {\n          continue;\n        }\n\n        let expired = true;\n        if (idle !== null) {\n          expired = idle.timeRemaining() < 0;\n        }\n        if (expired) {\n          this.checkFirstEmoji_();\n          idle = await (new Promise(resolve => window.requestIdleCallback(resolve)));\n        }\n      }\n\n      this.checkFirstEmoji_();\n      return valid;\n    }.call(this));\n  }\n}\n\n// key overrides to recognize spacebar causing 'click'\nlet spaceFrame = 0;\nchooser.addEventListener('keyup', ev => {\n  if (ev.key !== ' ' || ev.target.localName !== 'button') { return; }\n  spaceFrame = window.setTimeout(() => spaceFrame = 0, 0);\n});\n\n// button click handler\nchooser.addEventListener('click', ev => {\n  let label = undefined;\n  const b = ev.target;\n  if (b.localName !== 'button') {\n    // ignore\n  } else if (b.parentNode.dataset['modifier']) {\n    const value = 'value' in b.dataset ? (+b.dataset['value'] || b.dataset['value']) : null;\n    const detail = {type: b.parentNode.dataset['modifier'], code: value};\n    typer.dispatchEvent(new CustomEvent('modifier', {detail}));\n    label = 'modifier';\n  } else if (b.parentNode.dataset['name']) {\n    // nb. we typically clear the word on choice (as it confuses @nickyringland), but if you hit\n    // space or ctrl-click the button, keep it around.\n    const retainWord = (spaceFrame !== 0 || ev.metaKey || ev.ctrlKey);\n    const word = retainWord ? b.parentNode.dataset['name'] : null;\n\n    const detail = {choice: b.textContent, word};\n    typer.dispatchEvent(new CustomEvent('emoji', {detail}));\n    provider.select(b.parentNode.dataset['name'], detail.choice);\n    label = 'emoji';\n  } else {\n    // unknown\n  }\n  label && ga('send', 'event', 'options', 'click', label);\n});\n\n// handle moving down from input\ntyper.addEventListener('keydown', ev => {\n  if (ev.key === 'ArrowDown' || ev.key === 'Down') {\n    const first = chooser.querySelector('button');\n    if (first) {\n      first.focus();\n      ga('send', 'event', 'options', 'keyboardnav');\n    }\n  }\n});\n\nconst arrowKeys = ['Left', 'Right', 'Up', 'Down'];\nconst isArrowKey = key => {\n  return key.startsWith('Arrow') || arrowKeys.indexOf(key) !== -1;\n};\n\n// handle keyboard navigation inside chooser\nchooser.addEventListener('keydown', ev => {\n  switch (ev.key) {\n  case 'Escape':\n    typer.focus();\n    break;\n  }\n  if (!isArrowKey(ev.key)) { return; }\n  if (!document.activeElement || !chooser.contains(document.activeElement)) { return; }\n\n  // TODO: memoize value\n  const buttonArray = Array.from(chooser.querySelectorAll('button'));\n  const index = buttonArray.indexOf(document.activeElement);\n  if (index === -1) { return; }\n\n  // handle l/r keys\n  let delta;\n  if (ev.key === 'ArrowLeft' || ev.key === 'Left') {\n    delta = -1;\n  } else if (ev.key === 'ArrowRight' || ev.key === 'Right') {\n    delta = +1;\n  }\n  if (delta) {\n    const target = index + delta;\n    if (target >= 0 && target < buttonArray.length) {\n      buttonArray[target].focus();\n    }\n    return;  // done\n  }\n\n  // handle u/d keys\n  if (ev.key === 'ArrowUp' || ev.key === 'Up') {\n    delta = -1;\n  } else if (ev.key === 'ArrowDown' || ev.key === 'Down') {\n    delta = +1;\n  } else {\n    return;\n  }\n  const previousRect = document.activeElement.getBoundingClientRect();\n  const best = {dist: Infinity, button: null};\n\n  let targetTop = undefined;\n  let candidate = index;\n  while ((candidate += delta) >= 0 && candidate < buttonArray.length) {\n    const button = buttonArray[candidate];\n    const candidateRect = button.getBoundingClientRect();\n\n    if (previousRect.top === candidateRect.top) { continue; }\n    if (targetTop === undefined) {\n      targetTop = candidateRect.top;\n    }\n    if (candidateRect.top !== targetTop) {\n      break;  // no more good candidates\n    }\n\n    const dist = Math.abs(candidateRect.left - previousRect.left);\n    if (dist < best.dist) {\n      [best.dist, best.button] = [dist, button];\n    }\n  }\n\n  if (best.button) {\n    best.button.focus();\n  } else if (targetTop === undefined && delta < 0) {\n    // if we were at top and going -ve, then return to input\n    typer.focus();\n  }\n});\n\n(function() {\n  const longTime = 2000;\n  const delayTime = 250;\n  const manager = new ButtonManager(chooser);\n\n  let previous = {};\n  let previousQueryAt = performance.now();\n  let pendingFirstEmojiRequest = null;\n\n  // handler for a prefix search\n  typer.addEventListener('query', ev => {\n    // immediately inform manager of modifier buttons (gender, tone), if it's a full word search\n    const info = modifier.modify(!ev.detail.prefix && ev.detail.focus || '');\n    manager.setModifier(info);\n\n    pendingFirstEmojiRequest = null;  // user typed something else\n\n    let immediate = false;\n    const now = performance.now();\n    const query = ev.detail;\n    if (!previous.text || previous.prefix !== query.prefix) {\n      immediate = true;  // type changed, user expects snappiness\n    } else if (now - previousQueryAt > longTime) {\n      immediate = true;  // it's been a while\n    }\n    previous = query;\n    previousQueryAt = now;\n\n    const request = async (timeout=0, more=false) => {\n      if (timeout) {\n        await new Promise((resolve) => window.setTimeout(() => {\n          window.requestAnimationFrame(resolve);\n        }, timeout));\n        if (previous !== query) { return -1; }\n      }\n      const results = await provider.request(query.text, query.prefix, more);\n      if (previous !== query) { return -1; }\n\n      // TODO: rather than discarding, can we work out whether this is something we can _filter_\n      // to _look_ like the real results?\n      // nb. we'd have to say... this is \"old\" but the final one hasn't finished.\n\n      return manager.update(results);\n    };\n\n    const p = request(immediate ? 0 : delayTime).then((valid) => {\n      if (valid < 0) { return -2; }  // query changed\n\n      // TODO: the 'more' behaviour interacts oddly with pendingFirstEmojiRequest, as it can appear\n      // as if your emoji changes after a _long_ time.\n\n      const timeout = Math.max(1000, 100 * Math.pow(valid, 0.75));\n      return request(timeout, true);\n    }).catch(err => {\n      console.error('error doing request', err);\n    });\n  });\n\n  // nb. this punctuation list is just misc stuff needed by emojimap\n  const invalidLetterRe = /[^\\w:\\.,$%^\\-']+/g;\n  const simplifyWord = word => word.replace(invalidLetterRe, '').toLowerCase();\n\n  // request an autocomplete, the user has just kept typing\n  typer.addEventListener('request', ev => {\n    const word = simplifyWord(ev.detail || '');\n    const request = manager.firstEmojiForOption(word);\n    pendingFirstEmojiRequest = request;\n    request.then(choice => {\n      if (pendingFirstEmojiRequest !== request) { return; }\n\n      ga('send', 'event', 'options', 'typing');\n      const detail = {choice, word};\n      typer.dispatchEvent(new CustomEvent('emoji', {detail}));\n    });\n  });\n}());\n","\nconst value = ev => {\n  const text = ev.detail.trim();\n  // we don't use .toggle, as it has an IE11 bug\n  if (text) {\n    document.body.classList.add('has-value');\n  } else {\n    document.body.classList.remove('has-value');\n  }\n};\ntyper.addEventListener('value', value);\nvalue({detail: typer.value});\n\n// set minHeight to actual viewport height, but allow for keyboard etc\nconst resize = ev => {\n  const height = window.innerHeight;\n  document.body.style.minHeight = `${height}px`;\n};\nwindow.addEventListener('resize', resize);\nresize();\n","\nif (navigator.serviceWorker) {\n  navigator.serviceWorker.register('./sw.js').catch(err => {\n    console.warn('failed to register SW', err);\n  });\n}\n"]}