{"version":3,"file":"bundle.js","sources":["src/lib/modifier.js","src/input.js","src/lib/provider.js","src/buttons.js","src/options.js","src/selection.js"],"sourcesContent":["\n/**\n * @param {string} string to measure\n * @return {number} length of text in monospace units\n */\nconst measureText = (function() {\n  const canvas = document.createElement('canvas');\n  const context = canvas.getContext('2d');\n  context.font = '1px monospace';\n\n  let cache = {};\n  let count = 0;\n\n  return s => {\n    let result = cache[s];\n    if (result === undefined) {\n      cache[s] = result = context.measureText(s).width;\n      if (++count > 4000) {\n        // nb. at June 2017, there's about ~1,800 emojis including variations, so this number is\n        // probably greater than we'll ever use: still, empty if it's too big\n        cache = {};\n        count = 0;\n      }\n    }\n    return result;\n  };\n}());\n\n/**\n * @type {boolean} whether this platform probably has fixed width emoji\n */\nconst fixedWidthEmoji = Boolean(/Mac|Android|iP(hone|od|ad)/);\n\n/**\n * @param {string} string to measure\n * @return {boolean} whether this is a single char long (and probably a single emoji)\n */\nconst isSingle = (function() {\n  if (fixedWidthEmoji) {\n    // get a baseline emoji width: this is the well-supported 'FACE WITH TEARS OF JOY'\n    const emojiWidth = measureText('\\u{1f602}');\n    return s => measureText(s) === emojiWidth;\n  }\n  const invalidWidth = context.measureText('\\u{ffffd}').width;\n  return s => {\n    const width = measureText(s);\n    return width !== invalidWidth && width < invalidWidth * 2;\n  };\n}());\n\n/**\n * Is this string rendering correctly as an emoji or sequence of emojis? On variable width\n * platforms, this can take O(n).\n *\n * @param {string} string to check\n * @return {boolean} whether this is probably an emoji\n */\nexport const isExpectedLength = (function() {\n  if (fixedWidthEmoji) {\n    // use 'FACE WITH TEARS OF JOY'\n    const emojiWidth = measureText('\\u{1f602}');\n    return s => {\n      // emojis could be _smaller_ than expected, but not larger- and not random non-unit widths\n      const points = jsdecode(s);\n      const chars = splitEmoji(points);\n\n      // count flags, reduce expected by / 2\n      const flags = chars.reduce((total, char) => total += isFlagPoint(char[0].point) ? 1 : 0, 0);\n      const expectedLength = chars.length - Math.ceil(flags / 2);\n\n      const width = measureText(s) / emojiWidth;\n\n      // does this have non-emoji characters in it?\n      if (Math.floor(width) !== width) { return false; }\n\n      // otherwise, as long as we're equal or smaller\n      return width <= expectedLength;\n    };\n  }\n\n  const invalidWidth = context.measureText('\\u{ffffd}').width;\n  return s => {\n    const points = jsdecode(s);\n    const chars = splitEmoji(points);\n\n    for (let i = 0; i < chars.length; ++i) {\n      const char = chars[i];\n      if (isFlagPoint(char[0].point)) {\n        if (i === chars.length - 1 || !isFlagPoint(char[i+1].point)) {\n          return false;  // only one single flag point\n        }\n\n        const s = String.fromCodePoint(...char[i].point, char[i+1].point);\n        if (!isSingle(s)) {\n          return false;  // can't render this flag\n        }\n\n        ++i;  // eaten next flag char\n        continue;\n      }\n\n      // otherwise, measure this particular point and ensure it's single.\n      const s = String.fromCodePoint(...char.map(c => c.point));\n      if (!isSingle(s)) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n}());\n\n/**\n * True if the standard \"female\" icon can be varied with a diversity modifier. This is the basic\n * level of emoji diversity support, but doesn't imply support for all the professions.\n *\n * @type {boolean}\n */\nconst basicDiversity = (measureText('\\u{1f468}\\u{1f3fb}') === measureText('\\u{1f468}'));\n\n/**\n * @param {number} p\n * @return {boolean} whether the passed rune is a gender character\n */\nfunction isPointGender(p) {\n  return p === 0x2640 || p === 0x2642;\n}\n\n/**\n * @param {number} p\n * @return {boolean} whether the passed rune is a basic emoji person gender: Man or Woman\n */\nfunction isPersonGender(p) {\n  return p === 0x1f468 || p === 0x1f469;\n}\n\n/**\n * @param {number} p\n * @return {boolean} whether this is a subordinate member of a family sequence: boy/girl/baby\n */\nfunction isFamilyMember(p) {\n  return p === 0x1f476 || p === 0x1f466 || p === 0x1f467;\n}\n\n/**\n * @param {number} p\n * @return {boolean} whether the passed rune is a Variation_Selector\n */\nfunction isVariationSelector(p) {\n  return (p >= 0xfe00 && p <= 0xfe0f) || (p >= 0xe0100 && p <= 0xe01ef);\n}\n\n/**\n * @param {number} p\n * @return {boolean} whether the passed rune is a diversity selector (one of five skin tones)\n */\nfunction isDiversitySelector(p) {\n  return p >= 0x1f3fb && p <= 0x1f3ff;\n}\n\n/**\n * @param {number} p\n * @return {boolean} whether the passed rune is one of A-Z for flags\n */\nfunction isFlagPoint(p) {\n  return p >= 0x1f1e6 && p <= 0x1f1ff;\n}\n\n/**\n * @param {number} p\n * @return {boolean} whether the passed rune is probably not a modifier base\n */\nfunction unlikelyModifierBase(p) {\n  return p < 0x261d || isPointGender(p) || isVariationSelector(p) || isDiversitySelector(p) ||\n      isFlagPoint(p);\n}\n\n/**\n * Decodes a JavaScript string into Unicode code points.\n *\n * @param {string} s to decode\n * @return {!Array<number>} code points\n */\nfunction jsdecode(s) {\n  const len = s.length;\n  const points = [];\n\n  for (let i = 0; i < len;) {\n    const raw = s.charCodeAt(i++) || 0;\n    if (raw < 0xd800 || raw > 0xdbff || i === len) {\n      // not a high surrogate, or end of string\n    } else {\n      const extra = s.charCodeAt(i) || 0;\n      if ((extra & 0xfc00) === 0xdc00) {\n        // got a low surrogate, eat 2nd char\n        ++i;\n        points.push(0x10000 + (extra & 0x3ff) + ((raw & 0x3ff) << 10));\n        continue;\n      }\n    }\n    points.push(raw);\n  }\n\n  return points;\n}\n\n/**\n * Returns details about a character and whether it can be gender flipped to a single or neutral\n * gender. This contains emojis which, due to historical emoji reasons, aren't officially versions\n * of each other: e.g., Santa and Mrs. Claus, or Old {Man,Woman,Adult}.\n *\n * @param {number} point to look up in the other gender flips table\n * @return {{single: boolean, neutral: boolean, points: {f: number, m: number, n: number}}?}\n */\nconst genderFlip = (function() {\n  // TODO: covers F/M/neutral, but _not_ mixed (e.g. holding hands => no m/f combo)\n  const list = [\n    0x1f936, 0x1f385, 0,        // mrs. claus, santa\n    0x1f483, 0x1f57a, 0,        // dancers\n    0x1f470, 0x1f935, 0,        // bride, man in tuxedo\n    0x1f467, 0x1f466, 0,        // girl, boy\n    0x1f475, 0x1f474, 0x1f9d3,  // old {woman,man,adult}\n    0x1f46d, 0x1f46c, 0,        // women/men holding hands\n    0x1f478, 0x1f934, 0,        // princess, prince\n  ];\n\n  // build map with raw data only\n  const all = new Map();\n  for (let i = 0; i < list.length; i += 3) {\n    const data = {\n      points: {f: list[i], m: list[i+1], n: list[i+2]},\n    };\n    for (let j = 0; j < 3; ++j) {\n      const v = list[i+j];\n      if (v) {\n        if (all.has(v)) {\n          throw new Error('duplicate in gender list: ' + v);\n        }\n        all.set(v, data);\n      }\n    }\n  }\n\n  // return helper\n  return point => {\n    const out = all.get(point) || null;\n    if (out && out.single === undefined) {\n      // do the heavy lifting only when first fetched\n      out.single = isSingle(String.fromCodePoint(out.points.f)) &&\n          isSingle(String.fromCodePoint(out.points.m));\n      out.neutral = out.points.n && isSingle(String.fromCodePoint(out.points.n));\n    }\n    return out;\n  };\n}());\n\n/**\n * Splits a single emoji into raw characters, removing variants or diversity modifiers. Each\n * sub-array represents a character previously split by ZWJs.\n *\n * @param {!Array<number>} points\n * @return {!Array<!Array<{point: number, suffix: number}>>}\n */\nfunction splitEmoji(points) {\n  if (!points.length) {\n    return [];\n  }\n  let curr = [{point: points[0], suffix: 0}];\n  const out = [curr];\n\n  // TODO: doesn't deal with flags or regional letters\n  // flags are weird: U + N + A, for instance, will render the Namibia flag where the UN flag is\n  // not supported (but the UN flag where it is)- taking the left-most valid code\n  // NOTE: the regional flag letters are seen as _emoji_ on their own, at least on Mac.\n\n  for (let i = 1; i < points.length; ++i) {\n    const check = points[i];\n\n    if (isFlagPoint(curr[curr.length-1].point)) {\n      // previous was a flag, create a new one\n    } else if (isDiversitySelector(check) || isVariationSelector(check)) {\n      // store in suffix\n      curr[curr.length-1].suffix = check;\n      continue;\n    } else if (check === 0x200d) {\n      // push next char onto curr\n      const next = points[++i];\n      next && curr.push({point: next, suffix: 0});\n      continue;\n    }\n\n    // new character, reset\n    curr = [{point: check, suffix: 0}];\n    out.push(curr);\n  }\n  return out;\n}\n\n/**\n * Analyses or modifes an emoji string for modifier support: diversity and gender.\n *\n * This might be O(n), including the cost of measuring every individual character via measureText.\n *\n * @param {string} s\n * @param {{diversity: undefined|number, gender: undefined|string}=} opt_op\n * @return {out: (string|undefined), diversity: boolean, gender: {single: boolean, double: boolean, neutral: boolean}}\n */\nexport function modify(s, opt_op) {\n  const points = jsdecode(s);\n  const stats = {diversity: false, gender: {single: false, double: false, neutral: false}};\n\n  // split out gender modifierss and other variations with splitEmoji, walk chars\n  const chars = splitEmoji(points);\n  const record = (opt_op ? [] : null);\n  chars.some((char, i) => {\n    const first = char[0].point;\n    let genderable = 0;\n    let family = false;\n\n    // search for existing gender characters\n    char.forEach(ch => {\n      const p = ch.point;\n      if (isPointGender(p)) {\n        // we can remove or replace the point\n        stats.gender.single = true;\n        stats.gender.neutral = true;\n      } else if (isPersonGender(p)) {\n        // easily swappable person\n        stats.gender.single = true;\n        if (++genderable >= 2) {\n          stats.gender.double = true;\n        }\n      } else if (isFamilyMember(p) && genderable) {\n        // this run is a family (child and already has parent), so it can't be made diverse\n        family = true;\n      } else {\n        // look for potential gender flips\n        const flip = genderFlip(p);\n        if (flip) {\n          stats.gender.single |= flip.single;\n          stats.gender.neutral |= flip.neutral;\n        }\n      }\n    });\n\n    // check for professions ('non family person'): single initial person gender, not a family\n    const isSinglePerson =\n        genderable ? (isPersonGender(first) && genderable === 1 && !family) : undefined;\n    if (isSinglePerson) {\n      stats.diversity = basicDiversity;\n    }\n    if (record) {\n      // true: is a 'non family person', aka profession or disembodied head (diversity OK)\n      // false: is a family or other combined group of persons (no diversity)\n      // undefined: something else\n      record[i] = isSinglePerson;\n    }\n\n    // check for early exhaustive answer\n    if ((stats.diversity || !basicDiversity) && stats.gender.neutral) {\n      // ... don't finish 'some' early if we're recording gender data\n      return !record && stats.gender.single && stats.gender.double;\n    }\n\n    // skip if profession, low emojis (everything below Emoji_Modifier_Base) and male/female signs\n    if (isSinglePerson === false || unlikelyModifierBase(first)) { return; }\n\n    // do slow measure checks\n    // TODO: can we use \\p{Modifier_Base} as a faster check than measureText for +ve case?\n    const candidate = String.fromCodePoint(first);\n    if (basicDiversity && !stats.diversity && isSingle(candidate + '\\u{1f3fb}')) {\n      stats.diversity = true;\n    }\n    if (!stats.gender.neutral && isSingle(candidate + '\\u{200d}\\u{2640}\\u{fe0f}')) {\n      stats.gender.neutral = true;\n      stats.gender.single = true;\n    }\n  });\n\n  // early out without op\n  if (!opt_op) {\n    return stats;\n  }\n\n  // gender helper: modifies passed character to apply next gender (or returns new ch)\n  const nextGenderPoint = (function() {\n    const g = opt_op.gender || '';\n    let previousMaster;\n    let index;\n    return (master, opt_point, opt_allowOtherFlip) => {\n      if (previousMaster === undefined || master !== previousMaster) {\n        previousMaster = master;\n        index = 0;\n      } else {\n        ++index;\n      }\n      const next = g ? g[index % g.length] : '';\n      const point = opt_point || 0;\n      if (isPersonGender(point)) {\n        // if this is a person, return the alternative person (or make no change)\n        return next ? (next === 'm' ? 0x1f468 : 0x1f469) : point;\n      } else if (!point || isPointGender(point)) {\n        // if this is a point, return the alternative point (or clear)\n        return next ? (next === 'm' ? 0x2642 : 0x2640) : 0;\n      } else if (opt_allowOtherFlip) {\n        // do other gender flips: note that some of these have F/M/N, but not all have N\n        const flip = genderFlip(point);\n        if (flip) {\n          if (!next && flip.neutral) {\n            return flip.points.n;\n          } else if (next && flip.single) {\n            return next === 'm' ? flip.points.m : flip.points.f;\n          }\n        }\n      }\n      // didn't consume anything\n      --index;\n      return point;\n    };\n  }());\n\n  // walk over all chars, apply change\n  const out = chars.map((char, i) => {\n    const points = [];  // used as nonce, declare first\n    const isSinglePerson = record[i];\n    const first = char[0].point;\n\n    if (opt_op.gender !== undefined) {\n      // replace/remove existing male/female characters\n      // nb. this removes orphaned gender point characters\n      const allowOtherFlip = (isSinglePerson === undefined);  // not for family/profession\n      char.forEach(ch => ch.point = nextGenderPoint(points, ch.point, allowOtherFlip));\n\n      // under various conditions, add a gender modifier to a single point\n      if (isSinglePerson === undefined && char.length === 1 && !isPointGender(first)) {\n        const genderPoint = nextGenderPoint(points);\n        if (genderPoint && isSingle(String.fromCodePoint(first) + '\\u{200d}\\u{2640}\\u{fe0f}')) {\n          char.push({suffix: 0xfe0f, point: genderPoint});\n        }\n      }\n    }\n\n    // apply diversity\n    if (opt_op.diversity !== undefined) {\n      char.forEach((ch, i) => {\n        if (isDiversitySelector(ch.suffix)) {\n          // always tweak existing diversity modifiers\n          ch.suffix = opt_op.diversity;\n        } else if (i === 0 && basicDiversity && isSinglePerson !== false) {\n          // if it's the first point in a non-family, try to apply diversity\n          if (isSinglePerson || isSingle(String.fromCodePoint(first) + '\\u{1f3fb}')) {\n            ch.suffix = opt_op.diversity;\n          }\n        }\n      });\n    }\n\n    // flatten into actual codepoints again\n    char.forEach(ch => {\n      if (ch.point) {\n        points.length && points.push(0x200d);\n        points.push(ch.point);\n        ch.suffix && points.push(ch.suffix);\n      }\n    });\n    return points;\n  }).reduce((all, points) => all.concat(points), []);\n\n  stats.out = String.fromCodePoint(...out);\n  return stats;\n};\n","\nimport * as modifier from './lib/modifier.js';\n\n// word focus handler\nfunction upgrade(el) {\n  const isWordCode = code => {\n    // FIXME: turns out matching non-emoji is hard\n    // TODO: this RegExp _might_ work but it needs transpiling-\n    // new RegExp(/(?:[\\p{Letter}\\p{Number}\\p{Punctuation}](?!\\u{fe0f}?\\u{20e3}))+/u);\n    return code < 5000 && code != 32;\n  };\n\n  const helper = document.createElement('div');\n  helper.className = 'overflow-helper';\n  el.parentNode.insertBefore(helper, el);\n\n  const underline = document.createElement('div');\n  underline.className = 'underline';\n  helper.appendChild(underline);\n\n  const sizer = document.createElement('div');\n  sizer.className = 'sizer';\n  helper.appendChild(sizer);\n\n  // hide underline until load: the font used might not be ready, so it's probably out of whack\n  if (document.readyState !== 'complete') {\n    underline.classList.add('loading');\n    window.addEventListener('load', ev => {\n      renderLine();\n      underline.classList.remove('loading');\n    });\n  }\n\n  const renderLine = _ => {\n    if (el.dataset.from === undefined) {\n      underline.hidden = true;\n      return false;\n    }\n    const [from, to] = [+el.dataset.from, +el.dataset.to];\n\n    // otherwise, record and draw the line\n    const indent = 15;  // FIXME: from CSS, to match `text-indent`\n    sizer.textContent = el.value.substr(0, from);\n    const left = (from ? sizer.getBoundingClientRect().width : indent);\n\n    sizer.textContent = el.value.substr(from, to - from);\n    const width = sizer.getBoundingClientRect().width - indent;\n\n    if (width < 0 && !document.getElementById('less')) {\n      // nb. this seems to happen in dev with lesscss\n      console.warn('invalid sizer width', width, 'for text', sizer.textContent);\n    }\n\n    underline.hidden = width <= 0;\n    underline.style.left = left + 'px';\n    underline.style.width = width + 'px';\n    underline.style.transform = 'translateX(-' + el.scrollLeft + 'px)';\n  };\n\n  // force selection\n  const setRange = (from, to) => {\n    if (from >= to) {\n      ['from', 'to', 'prefix', 'word', 'focus'].forEach(key => delete(el.dataset[key]));\n      underline.hidden = true;\n      return false;\n    }\n    [el.dataset.from, el.dataset.to] = [from, to];\n    el.dataset['focus'] = el.value.substr(from, to - from);\n    renderLine();\n    return true;\n  };\n\n  // state/handler keep track of the current focus word (plus scroll position, if input is big)\n  const initialLength = el.value.length;\n  const state = {start: initialLength, end: initialLength, value: undefined};\n  const changeHandler = permitNextChange => {\n    if (permitNextChange !== false &&\n        el.selectionStart === state.start &&\n        el.selectionEnd === state.end &&\n        el.value === state.value) {\n      return true;  // already at this state\n    }\n    [state.start, state.end] = [el.selectionStart, el.selectionEnd];\n    if (state.value !== el.value) {\n      el.dispatchEvent(new CustomEvent('value', {detail: el.value}));\n      state.value = el.value;\n    }\n\n    // range selection, magic\n    if (state.start !== state.end) {\n      delete(el.dataset['prefix']);\n      delete(el.dataset['word']);\n\n      setRange(state.start, state.end);\n\n      underline.classList.add('range');\n      el.classList.add('range');\n      return false;\n    }\n    underline.classList.remove('range');\n    el.classList.remove('range');\n\n    // calculate from/to locally\n    let from = state.start;\n    let to = state.start;\n\n    // are we at the end (only have spaces until end)?\n    const isAtEnd = !el.value.substr(state.end).trim();\n    const isNotWordAfter = isAtEnd || !isWordCode(el.value.charCodeAt(state.end));\n\n    if (isNotWordAfter) {\n      for (; to > 0; --to) {\n        if (el.value.charCodeAt(to - 1) !== 32) {\n          break;\n        }\n      }\n      if (to < from) {\n        from = to;\n      }\n    }\n\n    // walk backwards while the previous character is a word\n    for (; from > 0; --from) {\n      if (!isWordCode(el.value.charCodeAt(from - 1))) {\n        break;\n      }\n    }\n\n    // walk forwards while the next char is not a space\n    for (; to < el.value.length; ++to) {\n      if (!isWordCode(el.value.charCodeAt(to))) {\n        break;\n      }\n    }\n\n    // if it's invalid, but there's not a word after, and we were permitted, ignore\n    if (from >= to && isNotWordAfter && permitNextChange) { return; }\n    if (setRange(from, to)) {\n      // if the range was valid, update the prefix/focus but delete the word (in typing state)\n      el.dataset['focus'] = el.dataset['prefix'] = el.value.substr(from, to - from);\n      delete(el.dataset['word']);\n    }\n  };\n\n  // runs change handler and emits the 'word' event as appropriate\n  const mergedEventHandler = (events, permitNextChange) => {\n    // if there was a focus event, don't let the browser take over: reset previous known good\n    if (events.has('focus')) {\n      // only if it wasn't a range selection (otherwise clicking back retains range, weird)\n      if (state.start === state.end) {\n        // TODO: this sets on initial load, even though it probably doesn't need to\n        [el.selectionStart, el.selectionEnd] = [state.start, state.end];\n      }\n    }\n\n    // run change handler: if true, nothing changed\n    if (changeHandler(permitNextChange)) { return; }\n\n    // send query: prefix or whole-word\n    let text = el.dataset.prefix || el.dataset.word || null;\n    const detail = {text, prefix: 'prefix' in el.dataset, focus: el.dataset.focus};\n    el.dispatchEvent(new CustomEvent('query', {detail}));\n  };\n\n  // dedup listeners on a rAF\n  let permitNextChange;  // FIXME: global-ish scope is ugly\n  (function() {\n    let frame;\n    let events = new Set();  // records the events that occured to cause this\n    const dedup = ev => {\n      if (!frame) {\n        permitNextChange = undefined;\n        events.clear();\n        frame = window.requestAnimationFrame(_ => {\n          frame = null;\n          mergedEventHandler(events, permitNextChange);\n        });\n      }\n      ev && events.add(ev.type);\n    };\n\n    // lots of listeners for a million different change reasons\n    const rest = 'change keydown keypress focus click mousedown select input';\n    rest.split(/\\s+/).forEach(event => el.addEventListener(event, dedup));\n    dedup();\n\n    el.addEventListener('mousemove', ev => {\n      if (ev.which) {\n        dedup();\n      }\n    })\n\n  }());\n\n  // on blur, after a backspace, Chrome moves the start/end selection: fix it\n  el.addEventListener('blur', ev => {\n    if (el.selectionStart !== state.start || el.selectionStart !== state.end) {\n      [el.selectionStart, el.selectionEnd] = [state.start, state.end];\n    }\n  });\n\n  // add a non-deduped keydown handler, to run before others and intercept space\n  el.addEventListener('keydown', ev => {\n    switch (ev.key) {\n    case 'Escape':\n      permitNextChange = false;  // force next change\n      break;\n\n    case ' ':\n      if (el.dataset.prefix && el.selectionStart === +el.dataset.to) {\n        el.dispatchEvent(new CustomEvent('request', {detail: el.dataset.prefix}));\n      }\n\n      // TODO: do this to prevent actually space being hit (as \"Sam Prefers\")\n      //ev.preventDefault();\n      break;\n    }\n  });\n\n  // dedup re-rendering calls\n  (function() {\n    let frame;\n    const dedupRenderLine = _ => {\n      if (!frame) {\n        frame = window.requestAnimationFrame(_ => {\n          frame = null;\n          renderLine();\n        });\n      }\n    };\n    window.addEventListener('resize', dedupRenderLine);\n    el.addEventListener('wheel', dedupRenderLine, {passive: true});\n  }());\n\n  // replace helper\n  const replaceFocus = call => {\n    if (el.dataset.from === undefined || el.dataset.to === undefined) { return false; }\n\n    const [from, to] = [+el.dataset.from, +el.dataset.to];\n    const value = el.value.substr(from, to - from);\n    let [start, end] = [typer.selectionStart, typer.selectionEnd];\n\n    const update = call(value);\n    if (update == null) { return false; }\n    typer.value = typer.value.substr(0, from) + update + typer.value.substr(to);\n\n    const drift = where => {\n      if (where > to) {\n        // after the update\n        where = where - (to - from) + update.length;\n      } else if (where > from) {\n        // during the update\n        where = from + update.length;\n      } else {\n        // do nothing, was before\n      }\n      return where;\n    };\n\n    typer.focus();\n    typer.dispatchEvent(new CustomEvent('change'));  // nb. updates from/to (from won't change)\n    // pretend we were like this all along\n    [state.start, state.end] = [typer.selectionStart, typer.selectionEnd] = [drift(start), drift(end)];\n\n    permitNextChange = true;\n    setRange(from, from + update.length);\n    return true;\n  };\n\n  // handle 'modifier' event: apply modifiers to the focus word, if any\n  el.addEventListener('modifier', ev => {\n    const arg = {[ev.detail.type]: ev.detail.code};\n    replaceFocus(value => modifier.modify(value, arg).out || '');\n  });\n\n  // handle 'emoji' event: if there's a current focus word, then replace it with the new emoji \\o/\n  el.addEventListener('emoji', ev => {\n    const emoji = ev.detail.choice;\n    if (!replaceFocus(_ => emoji)) { return; }\n\n    // if this was a prefix match, now it's a word match (the word masks the emoji)\n    el.dataset['word'] = ev.detail.word || el.dataset['prefix'];\n    delete(el.dataset['prefix']);\n  });\n}\n\nupgrade(typer);\n","const api = 'https://emojityper.appspot.com';\n\nconst data = window.fetch(api + '/popular').then(out => out.json());\nlet indexed = data.then(emojimap => {\n  const prefixLength = 3;   // generate prefixes up to this length\n  const maxSuggestions = 10;  // only generate this many suggestions\n  const prefixSuggest = {};\n\n  for (let k in emojimap) {\n    const prefix = k.substr(0, prefixLength);\n    for (let i = 1; i <= prefix.length; ++i) {\n      const part = prefix.substr(0, i);\n      let opts = prefixSuggest[part];\n      if (!opts) {\n        opts = prefixSuggest[part] = [];\n      }\n      if (opts.length < maxSuggestions) {\n        opts.push(k);\n      }\n    }\n  }\n\n  return function(typed) {\n    typed = typed.toLowerCase();\n    const rest = typed.substr(prefixLength);\n    let all = prefixSuggest[typed.substr(0, prefixLength)] || [];\n\n    if (rest) {\n      all = all.filter(word => word.substr(prefixLength).startsWith(rest));\n    }\n    all = all.map(word => {\n      return {'name': word, 'options': emojimap[word] || []};\n    });\n\n    return all.length ? all : null;\n  }\n});\n\nlet requestCallback = function() {};\n\nlet timeout;  // timeout handler for secondary query\nconst performRequest = (text, prefix) => {\n  window.clearTimeout(timeout);\n  if (!text) {\n    requestCallback(null);\n    return;\n  }\n\n  // TODO: only send extra query if there's not enough results, or the user hits 'more'\n  const localTimeout = window.setTimeout(_ => {\n    const data = new FormData();\n    data.append('q', text);\n    data.append('prefix', prefix)\n    window.fetch(api + '/query', {method: 'POST', data}).then(out => out.json()).then(send);\n  }, 2000);\n  timeout = localTimeout;\n\n  indexed.then(suggest => {\n    let results = suggest(text);\n    if (!prefix) {\n      results = results.filter(result => result['name'] === text);\n    }\n    send(results);\n  });\n\n  // nb. at end to hoist above 'localTimeout'\n  function send(out) {\n    if (timeout === localTimeout) {\n      requestCallback(out);\n    }\n  }\n};\n\nexport function request(text, prefix) {\n  window.requestAnimationFrame(_ => {\n    performRequest(text, prefix);\n  });\n}\n\nexport function submit(name, value) {\n  // const data = `name=${name}&emoji=${value}`;\n  // FIXME: we've disabled CORS for now; the response is actually useless anyway\n  // FIXME: however, the client now thinks this succeeds even when it 400s\n  const data = new FormData();\n  data.append('name', name);\n  data.append('emoji', value);\n  return window.fetch(api + '/name', {method: 'POST', data, mode: 'no-cors'});\n}\n\nexport function callback(callback) {\n  requestCallback = callback;\n}\n","\nconst all = Array.prototype.slice.call(buttons.querySelectorAll('button'));\n\nconst handler = ev => {\n  const text = (ev ? ev.detail : typer.value).trim();\n  const hasValue = Boolean(text);\n  document.body.classList.toggle('has-value', hasValue);\n  all.forEach(button => button.disabled = !hasValue);\n};\n\ntyper.addEventListener('value', handler);\nhandler();\n\n// copy handler\n(function(button, input) {\n  let timeout;\n  const defaultText = button.textContent;\n  const spaceRe = /\\s*/;\n\n  const copy = _ => {\n    const [start, end] = [input.selectionStart, input.selectionEnd];\n\n    // find start/end of content (trim, but find positions)\n    let left = 0;\n    let right = input.value.length;\n    if (input.selectionStart !== input.selectionEnd) {\n      left = input.selectionStart;\n      right = input.selectionEnd;\n    }\n    left += spaceRe.exec(input.value.substr(left))[0].length;\n    right = left + input.value.substr(left, right - left).trim().length;\n    if (right <= left) { return false; }\n\n    input.focus();\n    input.selectionStart = left;\n    input.selectionEnd = right;\n\n    let ok = false;\n    try {\n      ok = document.execCommand('copy');\n    } catch(e) {\n      console.warn('could not copy', e);\n      ok = false;\n    }\n    // restore previous selection\n    [input.selectionStart, input.selectionEnd] = [start, end];\n\n    if (!ok) { return true; }\n    console.info('copied', input.value.substr(left, right));\n\n    // show message\n    button.textContent = button.dataset.copied;\n    window.clearTimeout(timeout);\n    timeout = window.setTimeout(ev => {\n      button.textContent = defaultText;\n    }, 500);\n  };\n\n  input.addEventListener('keydown', ev => {\n    if (ev.key == 'Enter') {\n      button.click();\n      input.focus();\n    }\n  });\n  button.addEventListener('click', ev => {\n    copy();\n    button.focus();\n  });\n}(copy, typer));\n\n","\nimport * as provider from './lib/provider.js';\nimport * as modifier from './lib/modifier.js';\n\n// suggestion handler\n(function(input, chooser) {\n  // nb. this puncutation list is just misc stuff needed by emojimap\n  const invalidLetterRe = /[^\\w:\\.,$%^\\-']+/g;\n  const simplifyWord = word => {\n    if (word) {\n      return word.replace(invalidLetterRe, '').toLowerCase();\n    }\n    return null;\n  };\n\n  let buttonArray = [];\n\n  // button click handler\n  chooser.addEventListener('click', ev => {\n    const b = ev.target;\n    if (b.localName !== 'button') {\n      // ignore\n    } else if (b.dataset['modifier']) {\n      const value = 'value' in b.dataset ? (+b.dataset['value'] || b.dataset['value']) : null;\n      const detail = {type: b.dataset['modifier'], code: value};\n      input.dispatchEvent(new CustomEvent('modifier', {detail}));\n    } else {\n      const detail = {choice: b.textContent, word: b.dataset['word']};\n      input.dispatchEvent(new CustomEvent('emoji', {detail}));\n    }\n  });\n\n  // handle moving down from input\n  input.addEventListener('keydown', ev => {\n    if (ev.key === 'ArrowDown') {\n      const first = chooser.querySelector('button');\n      first && first.focus();\n    }\n  });\n\n  // handle keyboard navigation inside chooser\n  chooser.addEventListener('keydown', ev => {\n    switch (ev.key) {\n    case 'Escape':\n      input.focus();\n      break;\n    }\n    if (!ev.key.startsWith('Arrow')) { return; }\n\n    const index = buttonArray.indexOf(document.activeElement);\n    if (index === -1) { return; }\n\n    // handle l/r keys\n    let delta;\n    if (ev.key === 'ArrowLeft') {\n      delta = -1;\n    } else if (ev.key === 'ArrowRight') {\n      delta = +1;\n    }\n    if (delta) {\n      const target = index + delta;\n      if (target >= 0 && target < buttonArray.length) {\n        buttonArray[target].focus();\n      }\n      return;  // done\n    }\n\n    // handle u/d keys\n    if (ev.key === 'ArrowUp') {\n      delta = -1;\n    } else if (ev.key === 'ArrowDown') {\n      delta = +1;\n    } else {\n      return;\n    }\n    const previousRect = document.activeElement.getBoundingClientRect();\n    const best = {dist: Infinity, button: null};\n\n    let targetTop = undefined;\n    let candidate = index;\n    while ((candidate += delta) >= 0 && candidate < buttonArray.length) {\n      const button = buttonArray[candidate];\n      const candidateRect = button.getBoundingClientRect();\n\n      if (previousRect.top === candidateRect.top) { continue; }\n      if (targetTop === undefined) {\n        targetTop = candidateRect.top;\n      }\n      if (candidateRect.top !== targetTop) {\n        break;  // no more good candidates\n      }\n\n      const dist = Math.abs(candidateRect.left - previousRect.left);\n      if (dist < best.dist) {\n        [best.dist, best.button] = [dist, button];\n      }\n    }\n    if (best.button) {\n      best.button.focus();\n      return;\n    }\n\n    // if we were at top and going -ve, then return to input\n    if (targetTop === undefined && delta < 0) {\n      input.focus();\n      return;\n    }\n\n  });\n\n  let savedResults = null;\n  let query = null;\n  const show = results => {\n    chooser.textContent = '';\n    buttonArray.length = 0;\n    savedResults = results;\n\n    const createOptionsButtons = (heading, opt_class) => {\n      const el = document.createElement('div');\n      el.className = 'options';\n      opt_class && el.classList.add(opt_class);\n\n      const h4 = document.createElement('h4');\n      h4.textContent = heading;\n      el.appendChild(h4);\n\n      const buttons = document.createElement('div');\n      buttons.className = 'buttons';\n      el.appendChild(buttons);\n      chooser.appendChild(el);\n      return buttons;\n    };\n\n    const createButton = (holder, content) => {\n      const button = document.createElement('button');\n      button.textContent = content;\n      holder.appendChild(button);\n      buttonArray.push(button);\n      return button;\n    };\n\n    // if there's a focus but it's not a prefix (which implies that it's text-only)\n    if (query.focus && !query.prefix) {\n      const modifiers = {};\n      const createModifierButton = (type, text, opt_value) => {\n        let buttons = modifiers[type];\n        if (!buttons) {\n          modifiers[type] = buttons = createOptionsButtons(type, 'modifier');\n        }\n        const button = createButton(buttons, text);\n        button.dataset['modifier'] = type;\n        if (opt_value) {\n          button.dataset['value'] = opt_value;\n        }\n      };\n\n      const out = modifier.modify(query.focus);\n\n      out.gender.neutral && createModifierButton('gender', '\\u{2014}');\n      out.gender.single && createModifierButton('gender', '\\u{2640}', 'f');\n      out.gender.double && createModifierButton('gender', '\\u{2640}\\u{2642}', 'fm');\n      out.gender.single && createModifierButton('gender', '\\u{2642}', 'm');\n      out.gender.double && createModifierButton('gender', '\\u{2642}\\u{2640}', 'mf');\n\n      if (out.diversity) {\n        createModifierButton('diversity', '\\u{2014}');\n        for (let i = 0x1f3fb; i <= 0x1f3ff; ++i) {\n          createModifierButton('diversity', String.fromCodePoint(i), i);\n        }\n      }\n    }\n\n    // FIXME: slowly add these (over frames), to amortize rendering hit\n    // FIXME: we still get duplicates- some which are just force emoji / missing\n    (results || []).forEach(result => {\n      const name = result['name'];\n      let buttons = null;\n      result['options'].forEach(option => {\n        // TODO: If a user has allowed it, render all emojis (even invalid) anyway.\n        if (!modifier.isExpectedLength(option)) {\n          return;\n        }\n        if (!buttons) {\n          // create if we haven't already got it\n          buttons = createOptionsButtons(name);\n        }\n        const button = createButton(buttons, option);\n        button.dataset['word'] = name;\n      });\n    });\n\n    // set global class to indicate chooser visible\n    document.body.classList.toggle('has-chooser', buttonArray.length > 0);\n  };\n\n  // set global callback for show\n  provider.callback(show);\n\n  // handler for a prefix search\n  input.addEventListener('query', ev => {\n    query = ev.detail;\n    provider.request(query.text, query.prefix);\n  });\n\n  // request an autocomplete, the user has just kept typing\n  input.addEventListener('request', ev => {\n    const word = simplifyWord(ev.detail);\n    let choice = null;\n\n    (savedResults || []).some(result => {\n      if (result.name !== word) { return false; }\n      choice = result.options[0];\n      return true;\n    });\n\n    if (choice) {\n      const detail = {choice, word};\n      input.dispatchEvent(new CustomEvent('emoji', {detail}));\n    }\n  });\n}(typer, chooser));\n","\nimport * as provider from './lib/provider.js';\n\n// advanced handler\n(function(input, advanced) {\n  const form = advanced.querySelector('form');\n  const namer = form.querySelector('input');\n  const button = form.querySelector('button');\n\n  let focus = '';\n\n  input.addEventListener('query', ev => {\n    const query = ev.detail;\n    const selection = (query.text === null && query.focus !== undefined);\n    focus = query.focus;\n    advanced.hidden = !selection;\n    if (advanced.hidden) {\n      namer.value = '';\n    }\n  });\n\n  const handler = ev => {\n    button.disabled = !namer.value;\n  };\n  'input change'.split(/\\s+/).forEach(type => namer.addEventListener(type, handler));\n\n  form.addEventListener('submit', ev => {\n    ev.preventDefault();\n\n    form.classList.add('pending');\n    namer.disabled = true;\n    button.disabled = true;\n\n    const cleanup = _ => {\n      form.classList.remove('pending');\n      namer.disabled = false;\n      namer.value = '';\n      namer.dispatchEvent(new CustomEvent('change'));\n    };\n\n    const p = provider.submit(namer.value, focus).then(_ => {\n      button.classList.add('success');\n      return false;\n    }).catch(err => {\n      button.classList.add('failure');\n      console.warn('failed to submit emoji', err)\n      return true;\n    }).then(cleanup);\n\n    p.then(_ => new Promise((resolve, reject) => window.setTimeout(resolve, 2000))).then(_ => {\n      button.className = '';\n    });\n  });\n\n}(typer, advanced));\n"],"names":["isPointGender","p","isPersonGender","isFamilyMember","isVariationSelector","isDiversitySelector","isFlagPoint","unlikelyModifierBase","jsdecode","s","len","length","points","i","raw","charCodeAt","extra","push","splitEmoji","curr","point","suffix","out","check","next","modify","opt_op","stats","diversity","gender","single","double","neutral","chars","record","some","char","first","genderable","family","forEach","ch","flip","genderFlip","isSinglePerson","undefined","basicDiversity","candidate","String","fromCodePoint","isSingle","nextGenderPoint","g","previousMaster","index","master","opt_point","opt_allowOtherFlip","n","m","f","map","allowOtherFlip","genderPoint","reduce","all","concat","upgrade","el","isWordCode","code","helper","document","createElement","className","parentNode","insertBefore","underline","appendChild","sizer","readyState","classList","add","addEventListener","remove","renderLine","dataset","from","hidden","to","textContent","value","substr","left","getBoundingClientRect","width","getElementById","warn","style","transform","scrollLeft","setRange","key","initialLength","state","start","end","changeHandler","permitNextChange","selectionStart","selectionEnd","dispatchEvent","CustomEvent","detail","isNotWordAfter","trim","mergedEventHandler","events","has","text","prefix","word","focus","frame","Set","dedup","clear","window","requestAnimationFrame","ev","type","split","event","which","dedupRenderLine","passive","replaceFocus","typer","update","call","drift","where","arg","modifier","emoji","choice","request","submit","name","data","FormData","append","fetch","api","method","mode","callback","Array","prototype","slice","buttons","querySelectorAll","handler","hasValue","Boolean","body","toggle","button","disabled","input","timeout","defaultText","spaceRe","copy","right","exec","ok","execCommand","e","info","copied","clearTimeout","setTimeout","click","measureText","context","getContext","font","cache","count","result","fixedWidthEmoji","emojiWidth","invalidWidth","isExpectedLength","flags","total","expectedLength","Math","ceil","floor","c","list","Map","j","v","Error","set","get","then","json","indexed","prefixSuggest","k","emojimap","part","opts","typed","rest","toLowerCase","filter","startsWith","options","requestCallback","performRequest","send","localTimeout","results","suggest","chooser","invalidLetterRe","simplifyWord","replace","buttonArray","b","target","localName","querySelector","indexOf","activeElement","delta","previousRect","best","dist","Infinity","targetTop","candidateRect","top","abs","savedResults","query","createOptionsButtons","heading","opt_class","h4","createButton","holder","content","modifiers","createModifierButton","opt_value","option","advanced","form","namer","selection","preventDefault","provider","catch","err","Promise","resolve","reject"],"mappings":"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"}