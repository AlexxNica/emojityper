{"version":3,"file":"bundle.js","sources":["src/lib/modifier.js","src/input.js","src/lib/prefixgen.js","src/lib/provider.js","src/options.js","src/polyfill.js","src/buttons.js","src/selection.js"],"sourcesContent":["\n/**\n * @param {string} string to measure\n * @return {number} length of text in monospace units\n */\nconst measureText = (function() {\n  const canvas = document.createElement('canvas');\n  const context = canvas.getContext('2d');\n  context.font = '1px monospace';\n\n  let cache = {};\n  let count = 0;\n\n  return s => {\n    let result = cache[s];\n    if (result === undefined) {\n      cache[s] = result = context.measureText(s).width;\n      if (++count > 4000) {\n        // nb. at June 2017, there's about ~1,800 emojis including variations, so this number is\n        // probably greater than we'll ever use: still, empty if it's too big\n        cache = {};\n        count = 0;\n      }\n    }\n    return result;\n  };\n}());\n\n/**\n * @type {boolean} whether this platform probably has fixed width emoji\n */\nconst fixedWidthEmoji = Boolean(/Mac|Android|iP(hone|od|ad)/);\n\n/**\n * @param {string} string to measure\n * @return {boolean} whether this is a single char long (and probably a single emoji)\n */\nconst isSingle = (function() {\n  if (fixedWidthEmoji) {\n    // get a baseline emoji width: this is the well-supported 'FACE WITH TEARS OF JOY'\n    const emojiWidth = measureText('\\u{1f602}');\n    return s => measureText(s) === emojiWidth;\n  }\n  const invalidWidth = context.measureText('\\u{ffffd}').width;\n  return s => {\n    const width = measureText(s);\n    return width !== invalidWidth && width < invalidWidth * 2;\n  };\n}());\n\n/**\n * Is this string rendering correctly as an emoji or sequence of emojis? On variable width\n * platforms, this can take O(n).\n *\n * @param {string} string to check\n * @return {boolean} whether this is probably an emoji\n */\nexport const isExpectedLength = (function() {\n  if (fixedWidthEmoji) {\n    // use 'FACE WITH TEARS OF JOY'\n    const emojiWidth = measureText('\\u{1f602}');\n    return s => {\n      // emojis could be _smaller_ than expected, but not larger- and not random non-unit widths\n      const points = jsdecode(s);\n      const chars = splitEmoji(points);\n\n      // count flags, reduce expected by / 2\n      const flags = chars.reduce((total, char) => total += isFlagPoint(char[0].point) ? 1 : 0, 0);\n      const expectedLength = chars.length - Math.ceil(flags / 2);\n\n      const width = measureText(s) / emojiWidth;\n\n      // does this have non-emoji characters in it?\n      if (Math.floor(width) !== width) { return false; }\n\n      // otherwise, as long as we're equal or smaller\n      return width <= expectedLength;\n    };\n  }\n\n  const invalidWidth = context.measureText('\\u{ffffd}').width;\n  return s => {\n    const points = jsdecode(s);\n    const chars = splitEmoji(points);\n\n    for (let i = 0; i < chars.length; ++i) {\n      const char = chars[i];\n      if (isFlagPoint(char[0].point)) {\n        if (i === chars.length - 1 || !isFlagPoint(char[i+1].point)) {\n          return false;  // only one single flag point\n        }\n\n        const s = String.fromCodePoint(...char[i].point, char[i+1].point);\n        if (!isSingle(s)) {\n          return false;  // can't render this flag\n        }\n\n        ++i;  // eaten next flag char\n        continue;\n      }\n\n      // otherwise, measure this particular point and ensure it's single.\n      const s = String.fromCodePoint(...char.map(c => c.point));\n      if (!isSingle(s)) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n}());\n\n/**\n * True if the standard \"female\" icon can be varied with a diversity modifier. This is the basic\n * level of emoji diversity support, but doesn't imply support for all the professions.\n *\n * @type {boolean}\n */\nconst basicDiversity = (measureText('\\u{1f468}\\u{1f3fb}') === measureText('\\u{1f468}'));\n\n/**\n * @param {number} p\n * @return {boolean} whether the passed rune is a gender character\n */\nfunction isPointGender(p) {\n  return p === 0x2640 || p === 0x2642;\n}\n\n/**\n * @param {number} p\n * @return {boolean} whether the passed rune is a basic emoji person gender: Man or Woman\n */\nfunction isPersonGender(p) {\n  return p === 0x1f468 || p === 0x1f469;\n}\n\n/**\n * @param {number} p\n * @return {boolean} whether this is a subordinate member of a family sequence: boy/girl/baby\n */\nfunction isFamilyMember(p) {\n  return p === 0x1f476 || p === 0x1f466 || p === 0x1f467;\n}\n\n/**\n * @param {number} p\n * @return {boolean} whether the passed rune is a Variation_Selector\n */\nfunction isVariationSelector(p) {\n  return (p >= 0xfe00 && p <= 0xfe0f) || (p >= 0xe0100 && p <= 0xe01ef);\n}\n\n/**\n * @param {number} p\n * @return {boolean} whether the passed rune is a diversity selector (one of five skin tones)\n */\nfunction isDiversitySelector(p) {\n  return p >= 0x1f3fb && p <= 0x1f3ff;\n}\n\n/**\n * @param {number} p\n * @return {boolean} whether the passed rune is one of A-Z for flags\n */\nfunction isFlagPoint(p) {\n  return p >= 0x1f1e6 && p <= 0x1f1ff;\n}\n\n/**\n * @param {number} p\n * @return {boolean} whether the passed rune is probably not a modifier base\n */\nfunction unlikelyModifierBase(p) {\n  return p < 0x261d || isPointGender(p) || isVariationSelector(p) || isDiversitySelector(p) ||\n      isFlagPoint(p);\n}\n\n/**\n * Decodes a JavaScript string into Unicode code points.\n *\n * @param {string} s to decode\n * @return {!Array<number>} code points\n */\nfunction jsdecode(s) {\n  const len = s.length;\n  const points = [];\n\n  for (let i = 0; i < len;) {\n    const raw = s.charCodeAt(i++) || 0;\n    if (raw < 0xd800 || raw > 0xdbff || i === len) {\n      // not a high surrogate, or end of string\n    } else {\n      const extra = s.charCodeAt(i) || 0;\n      if ((extra & 0xfc00) === 0xdc00) {\n        // got a low surrogate, eat 2nd char\n        ++i;\n        points.push(0x10000 + (extra & 0x3ff) + ((raw & 0x3ff) << 10));\n        continue;\n      }\n    }\n    points.push(raw);\n  }\n\n  return points;\n}\n\n/**\n * Returns details about a character and whether it can be gender flipped to a single or neutral\n * gender. This contains emojis which, due to historical emoji reasons, aren't officially versions\n * of each other: e.g., Santa and Mrs. Claus, or Old {Man,Woman,Adult}.\n *\n * @param {number} point to look up in the other gender flips table\n * @return {{single: boolean, neutral: boolean, points: {f: number, m: number, n: number}}?}\n */\nconst genderFlip = (function() {\n  // TODO: covers F/M/neutral, but _not_ mixed (e.g. holding hands => no m/f combo)\n  const list = [\n    0x1f936, 0x1f385, 0,        // mrs. claus, santa\n    0x1f483, 0x1f57a, 0,        // dancers\n    0x1f470, 0x1f935, 0,        // bride, man in tuxedo\n    0x1f467, 0x1f466, 0,        // girl, boy\n    0x1f475, 0x1f474, 0x1f9d3,  // old {woman,man,adult}\n    0x1f46d, 0x1f46c, 0,        // women/men holding hands\n    0x1f478, 0x1f934, 0,        // princess, prince\n  ];\n\n  // build map with raw data only\n  const all = new Map();\n  for (let i = 0; i < list.length; i += 3) {\n    const data = {\n      points: {f: list[i], m: list[i+1], n: list[i+2]},\n    };\n    for (let j = 0; j < 3; ++j) {\n      const v = list[i+j];\n      if (v) {\n        if (all.has(v)) {\n          throw new Error('duplicate in gender list: ' + v);\n        }\n        all.set(v, data);\n      }\n    }\n  }\n\n  // return helper\n  return point => {\n    const out = all.get(point) || null;\n    if (out && out.single === undefined) {\n      // do the heavy lifting only when first fetched\n      out.single = isSingle(String.fromCodePoint(out.points.f)) &&\n          isSingle(String.fromCodePoint(out.points.m));\n      out.neutral = out.points.n && isSingle(String.fromCodePoint(out.points.n));\n    }\n    return out;\n  };\n}());\n\n/**\n * Splits a single emoji into raw characters, removing variants or diversity modifiers. Each\n * sub-array represents a character previously split by ZWJs.\n *\n * @param {!Array<number>} points\n * @return {!Array<!Array<{point: number, suffix: number}>>}\n */\nfunction splitEmoji(points) {\n  if (!points.length) {\n    return [];\n  }\n  let curr = [{point: points[0], suffix: 0}];\n  const out = [curr];\n\n  // TODO: doesn't deal with flags or regional letters\n  // flags are weird: U + N + A, for instance, will render the Namibia flag where the UN flag is\n  // not supported (but the UN flag where it is)- taking the left-most valid code\n  // NOTE: the regional flag letters are seen as _emoji_ on their own, at least on Mac.\n\n  for (let i = 1; i < points.length; ++i) {\n    const check = points[i];\n\n    if (isFlagPoint(curr[curr.length-1].point)) {\n      // previous was a flag, create a new one\n    } else if (isDiversitySelector(check) || isVariationSelector(check)) {\n      // store in suffix\n      curr[curr.length-1].suffix = check;\n      continue;\n    } else if (check === 0x200d) {\n      // push next char onto curr\n      const next = points[++i];\n      next && curr.push({point: next, suffix: 0});\n      continue;\n    }\n\n    // new character, reset\n    curr = [{point: check, suffix: 0}];\n    out.push(curr);\n  }\n  return out;\n}\n\n/**\n * Analyses or modifes an emoji string for modifier support: diversity and gender.\n *\n * This might be O(n), including the cost of measuring every individual character via measureText.\n *\n * @param {string} s\n * @param {{diversity: undefined|number, gender: undefined|string}=} opt_op\n * @return {out: (string|undefined), diversity: boolean, gender: {single: boolean, double: boolean, neutral: boolean}}\n */\nexport function modify(s, opt_op) {\n  const points = jsdecode(s);\n  const stats = {diversity: false, gender: {single: false, double: false, neutral: false}};\n\n  // split out gender modifierss and other variations with splitEmoji, walk chars\n  const chars = splitEmoji(points);\n  const record = (opt_op ? [] : null);\n  chars.some((char, i) => {\n    const first = char[0].point;\n    let genderable = 0;\n    let family = false;\n\n    // search for existing gender characters\n    char.forEach(ch => {\n      const p = ch.point;\n      if (isPointGender(p)) {\n        // we can remove or replace the point\n        stats.gender.single = true;\n        stats.gender.neutral = true;\n      } else if (isPersonGender(p)) {\n        // easily swappable person\n        stats.gender.single = true;\n        if (++genderable >= 2) {\n          stats.gender.double = true;\n        }\n      } else if (isFamilyMember(p) && genderable) {\n        // this run is a family (child and already has parent), so it can't be made diverse\n        family = true;\n      } else {\n        // look for potential gender flips\n        const flip = genderFlip(p);\n        if (flip) {\n          stats.gender.single |= flip.single;\n          stats.gender.neutral |= flip.neutral;\n        }\n      }\n    });\n\n    // check for professions ('non family person'): single initial person gender, not a family\n    const isSinglePerson =\n        genderable ? (isPersonGender(first) && genderable === 1 && !family) : undefined;\n    if (isSinglePerson) {\n      stats.diversity = basicDiversity;\n    }\n    if (record) {\n      // true: is a 'non family person', aka profession or disembodied head (diversity OK)\n      // false: is a family or other combined group of persons (no diversity)\n      // undefined: something else\n      record[i] = isSinglePerson;\n    }\n\n    // check for early exhaustive answer\n    if ((stats.diversity || !basicDiversity) && stats.gender.neutral) {\n      // ... don't finish 'some' early if we're recording gender data\n      return !record && stats.gender.single && stats.gender.double;\n    }\n\n    // skip if profession, low emojis (everything below Emoji_Modifier_Base) and male/female signs\n    if (isSinglePerson === false || unlikelyModifierBase(first)) { return; }\n\n    // do slow measure checks\n    // TODO: can we use \\p{Modifier_Base} as a faster check than measureText for +ve case?\n    const candidate = String.fromCodePoint(first);\n    if (basicDiversity && !stats.diversity && isSingle(candidate + '\\u{1f3fb}')) {\n      stats.diversity = true;\n    }\n    if (!stats.gender.neutral && isSingle(candidate + '\\u{200d}\\u{2640}\\u{fe0f}')) {\n      stats.gender.neutral = true;\n      stats.gender.single = true;\n    }\n  });\n\n  // early out without op\n  if (!opt_op) {\n    return stats;\n  }\n\n  // gender helper: modifies passed character to apply next gender (or returns new ch)\n  const nextGenderPoint = (function() {\n    const g = opt_op.gender || '';\n    let previousMaster;\n    let index;\n    return (master, opt_point, opt_allowOtherFlip) => {\n      if (previousMaster === undefined || master !== previousMaster) {\n        previousMaster = master;\n        index = 0;\n      } else {\n        ++index;\n      }\n      const next = g ? g[index % g.length] : '';\n      const point = opt_point || 0;\n      if (isPersonGender(point)) {\n        // if this is a person, return the alternative person (or make no change)\n        return next ? (next === 'm' ? 0x1f468 : 0x1f469) : point;\n      } else if (!point || isPointGender(point)) {\n        // if this is a point, return the alternative point (or clear)\n        return next ? (next === 'm' ? 0x2642 : 0x2640) : 0;\n      } else if (opt_allowOtherFlip) {\n        // do other gender flips: note that some of these have F/M/N, but not all have N\n        const flip = genderFlip(point);\n        if (flip) {\n          if (!next && flip.neutral) {\n            return flip.points.n;\n          } else if (next && flip.single) {\n            return next === 'm' ? flip.points.m : flip.points.f;\n          }\n        }\n      }\n      // didn't consume anything\n      --index;\n      return point;\n    };\n  }());\n\n  // walk over all chars, apply change\n  const out = chars.map((char, i) => {\n    const points = [];  // used as nonce, declare first\n    const isSinglePerson = record[i];\n    const first = char[0].point;\n\n    if (opt_op.gender !== undefined) {\n      // replace/remove existing male/female characters\n      // nb. this removes orphaned gender point characters\n      const allowOtherFlip = (isSinglePerson === undefined);  // not for family/profession\n      char.forEach(ch => ch.point = nextGenderPoint(points, ch.point, allowOtherFlip));\n\n      // under various conditions, add a gender modifier to a single point\n      if (isSinglePerson === undefined && char.length === 1 && !isPointGender(first)) {\n        const genderPoint = nextGenderPoint(points);\n        if (genderPoint && isSingle(String.fromCodePoint(first) + '\\u{200d}\\u{2640}\\u{fe0f}')) {\n          char.push({suffix: 0xfe0f, point: genderPoint});\n        }\n      }\n    }\n\n    // apply diversity\n    if (opt_op.diversity !== undefined) {\n      char.forEach((ch, i) => {\n        if (isDiversitySelector(ch.suffix)) {\n          // always tweak existing diversity modifiers\n          ch.suffix = opt_op.diversity;\n        } else if (i === 0 && basicDiversity && isSinglePerson !== false) {\n          // if it's the first point in a non-family, try to apply diversity\n          if (isSinglePerson || isSingle(String.fromCodePoint(first) + '\\u{1f3fb}')) {\n            ch.suffix = opt_op.diversity;\n          }\n        }\n      });\n    }\n\n    // flatten into actual codepoints again\n    char.forEach(ch => {\n      if (ch.point) {\n        points.length && points.push(0x200d);\n        points.push(ch.point);\n        ch.suffix && points.push(ch.suffix);\n      }\n    });\n    return points;\n  }).reduce((all, points) => all.concat(points), []);\n\n  stats.out = String.fromCodePoint(...out);\n  return stats;\n};\n","\nimport * as modifier from './lib/modifier.js';\n\nfunction datasetSafeDelete(el, ...keys) {\n  const d = el.dataset;\n  keys.forEach(key => {\n    if (key in d) {\n      delete d[key];\n    }\n  });\n}\n\n// word focus handler\nfunction upgrade(el) {\n  const isWordCode = code => {\n    // FIXME: turns out matching non-emoji is hard\n    // TODO: this RegExp _might_ work but it needs transpiling-\n    // new RegExp(/(?:[\\p{Letter}\\p{Number}\\p{Punctuation}](?!\\u{fe0f}?\\u{20e3}))+/u);\n    return code < 5000 && code != 32;\n  };\n\n  const helper = document.createElement('div');\n  helper.className = 'overflow-helper';\n  el.parentNode.insertBefore(helper, el);\n\n  const underline = document.createElement('div');\n  underline.className = 'underline';\n  helper.appendChild(underline);\n\n  const sizer = document.createElement('div');\n  sizer.className = 'sizer';\n  helper.appendChild(sizer);\n\n  // hide underline until load: the font used might not be ready, so it's probably out of whack\n  if (document.readyState !== 'complete') {\n    underline.classList.add('loading');\n    window.addEventListener('load', ev => {\n      renderLine();\n      underline.classList.remove('loading');\n    });\n  }\n\n  const renderLine = _ => {\n    if (el.dataset.from === undefined) {\n      underline.hidden = true;\n      return false;\n    }\n    const [from, to] = [+el.dataset.from, +el.dataset.to];\n\n    // otherwise, record and draw the line\n    const indent = 15;  // FIXME: from CSS, to match `text-indent`\n    sizer.textContent = el.value.substr(0, from);\n    const left = (from ? sizer.getBoundingClientRect().width : indent);\n\n    sizer.textContent = el.value.substr(from, to - from);\n    const width = sizer.getBoundingClientRect().width - indent;\n\n    if (width < 0 && !document.getElementById('less')) {\n      // nb. this seems to happen in dev with lesscss\n      console.warn('invalid sizer width', width, 'for text', sizer.textContent);\n    }\n\n    underline.hidden = width <= 0;\n    underline.style.left = left + 'px';\n    underline.style.width = width + 'px';\n    underline.style.transform = 'translateX(-' + el.scrollLeft + 'px)';\n  };\n\n  // force selection\n  const setRange = (from, to) => {\n    if (from >= to) {\n      datasetSafeDelete(el, 'from', 'to', 'prefix', 'word', 'focus');\n      underline.hidden = true;\n      return false;\n    }\n    [el.dataset.from, el.dataset.to] = [from, to];\n    el.dataset['focus'] = el.value.substr(from, to - from);\n    renderLine();\n    return true;\n  };\n\n  // state/handler keep track of the current focus word (plus scroll position, if input is big)\n  const initialLength = el.value.length;\n  const state = {start: initialLength, end: initialLength, value: undefined};\n  const changeHandler = permitNextChange => {\n    if (permitNextChange !== false &&\n        el.selectionStart === state.start &&\n        el.selectionEnd === state.end &&\n        el.value === state.value) {\n      return true;  // already at this state\n    }\n    [state.start, state.end] = [el.selectionStart, el.selectionEnd];\n    if (state.value !== el.value) {\n      el.dispatchEvent(new CustomEvent('value', {detail: el.value}));\n      state.value = el.value;\n    }\n\n    // range selection, magic\n    if (state.start !== state.end) {\n      datasetSafeDelete(el, 'prefix', 'word');\n\n      setRange(state.start, state.end);\n\n      underline.classList.add('range');\n      el.classList.add('range');\n      return false;\n    }\n    underline.classList.remove('range');\n    el.classList.remove('range');\n\n    // calculate from/to locally\n    let from = state.start;\n    let to = state.start;\n\n    // are we at the end (only have spaces until end)?\n    const isAtEnd = !el.value.substr(state.end).trim();\n    const isNotWordAfter = isAtEnd || !isWordCode(el.value.charCodeAt(state.end));\n\n    if (isNotWordAfter) {\n      for (; to > 0; --to) {\n        if (el.value.charCodeAt(to - 1) !== 32) {\n          break;\n        }\n      }\n      if (to < from) {\n        from = to;\n      }\n    }\n\n    // walk backwards while the previous character is a word\n    for (; from > 0; --from) {\n      if (!isWordCode(el.value.charCodeAt(from - 1))) {\n        break;\n      }\n    }\n\n    // walk forwards while the next char is not a space\n    for (; to < el.value.length; ++to) {\n      if (!isWordCode(el.value.charCodeAt(to))) {\n        break;\n      }\n    }\n\n    // if it's invalid, but there's not a word after, and we were permitted, ignore\n    if (from >= to && isNotWordAfter && permitNextChange) { return; }\n    if (setRange(from, to)) {\n      // if the range was valid, update the prefix/focus but delete the word (in typing state)\n      el.dataset['focus'] = el.dataset['prefix'] = el.value.substr(from, to - from);\n      datasetSafeDelete(el, 'word');\n    }\n  };\n\n  // runs change handler and emits the 'word' event as appropriate\n  const mergedEventHandler = (events, permitNextChange) => {\n    // if there was a focus event, don't let the browser take over: reset previous known good\n    if (events.has('focus')) {\n      // only if it wasn't a range selection (otherwise clicking back retains range, weird)\n      if (state.start === state.end) {\n        // TODO: this sets on initial load, even though it probably doesn't need to\n        [el.selectionStart, el.selectionEnd] = [state.start, state.end];\n      }\n    }\n\n    // run change handler: if true, nothing changed\n    if (changeHandler(permitNextChange)) { return; }\n\n    // send query: prefix or whole-word\n    let text = el.dataset.prefix || el.dataset.word || null;\n    const detail = {text, prefix: 'prefix' in el.dataset, focus: el.dataset.focus};\n    el.dispatchEvent(new CustomEvent('query', {detail}));\n  };\n\n  // dedup listeners on a rAF\n  let permitNextChange;  // FIXME: global-ish scope is ugly\n  (function() {\n    let frame;\n    let events = new Set();  // records the events that occured to cause this\n    const dedup = ev => {\n      if (!frame) {\n        permitNextChange = undefined;\n        events.clear();\n        frame = window.requestAnimationFrame(_ => {\n          frame = null;\n          mergedEventHandler(events, permitNextChange);\n        });\n      }\n      ev && events.add(ev.type);\n    };\n\n    // lots of listeners for a million different change reasons\n    const rest = 'change keydown keypress focus click mousedown select input';\n    rest.split(/\\s+/).forEach(event => el.addEventListener(event, dedup));\n    dedup();\n\n    el.addEventListener('mousemove', ev => {\n      if (ev.which) {\n        dedup();\n      }\n    })\n\n  }());\n\n  // on blur, after a backspace, Chrome moves the start/end selection: fix it\n  el.addEventListener('blur', ev => {\n    if (el.selectionStart !== state.start || el.selectionStart !== state.end) {\n      [el.selectionStart, el.selectionEnd] = [state.start, state.end];\n    }\n  });\n\n  // add a non-deduped keydown handler, to run before others and intercept space\n  el.addEventListener('keydown', ev => {\n    switch (ev.key) {\n    case 'Escape':\n      permitNextChange = false;  // force next change\n      break;\n\n    case ' ':\n      if (el.dataset.prefix && el.selectionStart === +el.dataset.to) {\n        el.dispatchEvent(new CustomEvent('request', {detail: el.dataset.prefix}));\n      }\n\n      // TODO: do this to prevent actually space being hit (as \"Sam Prefers\")\n      //ev.preventDefault();\n      break;\n    }\n  });\n\n  // dedup re-rendering calls\n  (function() {\n    let frame;\n    const dedupRenderLine = _ => {\n      if (!frame) {\n        frame = window.requestAnimationFrame(_ => {\n          frame = null;\n          renderLine();\n        });\n      }\n    };\n    window.addEventListener('resize', dedupRenderLine);\n    el.addEventListener('wheel', dedupRenderLine, {passive: true});\n  }());\n\n  // replace helper\n  const replaceFocus = call => {\n    if (el.dataset.from === undefined || el.dataset.to === undefined) { return false; }\n\n    const [from, to] = [+el.dataset.from, +el.dataset.to];\n    const value = el.value.substr(from, to - from);\n    let [start, end] = [typer.selectionStart, typer.selectionEnd];\n\n    const update = call(value);\n    if (update == null) { return false; }\n    typer.value = typer.value.substr(0, from) + update + typer.value.substr(to);\n\n    const drift = where => {\n      if (where > to) {\n        // after the update\n        where = where - (to - from) + update.length;\n      } else if (where > from) {\n        // during the update\n        where = from + update.length;\n      } else {\n        // do nothing, was before\n      }\n      return where;\n    };\n\n    typer.focus();\n    typer.dispatchEvent(new CustomEvent('change'));  // nb. updates from/to (from won't change)\n    // pretend we were like this all along\n    [state.start, state.end] = [typer.selectionStart, typer.selectionEnd] = [drift(start), drift(end)];\n\n    permitNextChange = true;\n    setRange(from, from + update.length);\n    return true;\n  };\n\n  // handle 'modifier' event: apply modifiers to the focus word, if any\n  el.addEventListener('modifier', ev => {\n    const arg = {[ev.detail.type]: ev.detail.code};\n    replaceFocus(value => modifier.modify(value, arg).out || '');\n  });\n\n  // handle 'emoji' event: if there's a current focus word, then replace it with the new emoji \\o/\n  el.addEventListener('emoji', ev => {\n    const emoji = ev.detail.choice;\n    if (!replaceFocus(_ => emoji)) { return; }\n\n    // if this was a prefix match, now it's a word match (the word masks the emoji)\n    el.dataset['word'] = ev.detail.word || el.dataset['prefix'];\n    datasetSafeDelete(el, 'prefix');\n  });\n}\n\nupgrade(typer);\n","\nexport default function build(raw, prefixLength=3, maxSuggestions=10) {\n  const prefixSuggest = {};\n\n  const values = {};\n  raw.forEach(data => {\n    const k = data[0];\n    values[k] = data.slice(1);\n\n    const prefix = k.substr(0, prefixLength);\n    for (let i = 1; i <= prefix.length; ++i) {\n      const part = prefix.substr(0, i);\n      let opts = prefixSuggest[part];\n      if (!opts) {\n        opts = prefixSuggest[part] = [];\n      }\n      if (opts.length < maxSuggestions) {\n        opts.push(k);\n      }\n    }\n  });\n\n  return function(typed) {\n    typed = typed.toLowerCase();\n    const rest = typed.substr(prefixLength);\n    let all = prefixSuggest[typed.substr(0, prefixLength)] || [];\n\n    if (rest) {\n      all = all.filter(word => word.substr(prefixLength).startsWith(rest));\n    }\n    all = all.map(word => {\n      return {'name': word, 'options': values[word] || []};\n    });\n\n    return all.length ? all : null;\n  }\n}\n","const api = 'https://us-central1-emojityper.cloudfunctions.net';\n\nimport build from './prefixgen.js';\n\nlet indexed;\ntry {\n  let data = JSON.parse(window.localStorage['popular']);\n  if (data['created'] >= (+new Date - 60 * 60 * 24 * 1000)) {\n    indexed = Promise.resolve(build(data['results']));\n    console.debug('got indexed localStorage');\n  }\n} catch (e) {\n  console.debug('couldn\\'t parse localStorage popular', e);\n}\nif (!indexed) {\n  // if no data or >1day old, refetch\n  const f = window.fetch(api + '/popular').then(out => out.json());\n  f.then(data => {\n    data['created'] = +new Date();\n    window.localStorage['popular'] = JSON.stringify(data);\n  });\n  const local = f.then(v => build(v['results']));\n  if (!indexed) {\n    indexed = local;\n  } else {\n    local.then(() => indexed = local);\n  }\n}\n\nlet requestCallback = function() {};\nlet timeout;  // timeout handler for secondary query\nconst performRequest = (text, prefix) => {\n  window.clearTimeout(timeout);\n  if (!text) {\n    requestCallback(null);\n    return;\n  }\n\n  // TODO: only send extra query if there's not enough results, or the user hits 'more'\n  const localTimeout = window.setTimeout(_ => {\n    let url = api + '/query?query=' + encodeURIComponent(text);\n    if (prefix) {\n      url += '&prefix=true';\n    }\n    // FIXME: don't ever clobber old results: maybe do this under \"more\" or if there's\n    // only very few results?\n    window.fetch(url)\n        .then(out => out.json())\n        .then(out => {\n          const all = out.results.map(arr => ({'name': arr[0], 'options': arr.slice(1)}));\n          send(all);\n        });\n  }, 2000);\n  timeout = localTimeout;\n\n  indexed.then(suggest => {\n    let results = suggest(text);\n    if (!prefix) {\n      results = results.filter(result => result['name'] === text);\n    }\n    send(results);\n  });\n\n  // nb. at end to hoist above 'localTimeout'\n  function send(out) {\n    if (timeout === localTimeout) {\n      requestCallback(out);\n    }\n  }\n};\n\nexport function request(text, prefix) {\n  window.requestAnimationFrame(_ => {\n    performRequest(text, prefix);\n  });\n}\n\nlet pendingSelect = {};\nlet timeoutSelect;\nexport function select(name, emoji) {\n  pendingSelect[name] = emoji;\n\n  window.clearTimeout(timeoutSelect);\n  timeoutSelect = window.setTimeout(_ => {\n    const body = JSON.stringify(pendingSelect);\n    pendingSelect = {};\n\n    // TODO: ugh promises\n    window.fetch(api + '/select', {method: 'POST', body})\n  }, 5 * 1000);\n}\n\nexport function submit(name, emoji) {\n  const body = new FormData();\n  body.append('name', name);\n  body.append('emoji', emoji);\n  return window.fetch(api + '/name', {method: 'POST', mode: 'cors', body});\n}\n\nexport function callback(callback) {\n  requestCallback = callback;\n}\n","\n// suggestion handler\n\nimport * as provider from './lib/provider.js';\nimport * as modifier from './lib/modifier.js';\n\n// nb. this puncutation list is just misc stuff needed by emojimap\nconst invalidLetterRe = /[^\\w:\\.,$%^\\-']+/g;\nconst simplifyWord = word => {\n  if (word) {\n    return word.replace(invalidLetterRe, '').toLowerCase();\n  }\n  return null;\n};\n\n/**\n * @type {Map<string, !HTMLButtonElement> cache of previously displayed buttons\n */\nlet buttonCache = new Map();\n\n/**\n * @param {string} text of button to create\n * @return {!HTMLButtonElement} button either from cache or newly created\n */\nfunction createButton(text) {\n  const candidate = buttonCache.get(text);\n  if (candidate) {\n    return candidate;\n  }\n  const button = document.createElement('button');\n  button.textContent = text;\n  buttonCache.set(text, button);\n  return button;\n}\n\n// button click handler\nchooser.addEventListener('click', ev => {\n  const b = ev.target;\n  if (b.localName !== 'button') {\n    // ignore\n  } else if (b.parentNode.dataset['modifier']) {\n    const value = 'value' in b.dataset ? (+b.dataset['value'] || b.dataset['value']) : null;\n    const detail = {type: b.parentNode.dataset['modifier'], code: value};\n    typer.dispatchEvent(new CustomEvent('modifier', {detail}));\n  } else {\n    const word = b.parentNode.dataset['word'];\n    const detail = {choice: b.textContent, word};\n    typer.dispatchEvent(new CustomEvent('emoji', {detail}));\n    provider.select(word, detail.choice);\n  }\n});\n\n// handle moving down from input\ntyper.addEventListener('keydown', ev => {\n  if (ev.key === 'ArrowDown') {\n    const first = chooser.querySelector('button');\n    first && first.focus();\n  }\n});\n\n// handle keyboard navigation inside chooser\nchooser.addEventListener('keydown', ev => {\n  switch (ev.key) {\n  case 'Escape':\n    typer.focus();\n    break;\n  }\n  if (!ev.key.startsWith('Arrow')) { return; }\n  if (!document.activeElement || !chooser.contains(document.activeElement)) { return; }\n\n  // TODO: memoize value\n  const buttonArray = Array.from(chooser.querySelectorAll('button'));\n  const index = buttonArray.indexOf(document.activeElement);\n  if (index === -1) { return; }\n\n  // handle l/r keys\n  let delta;\n  if (ev.key === 'ArrowLeft') {\n    delta = -1;\n  } else if (ev.key === 'ArrowRight') {\n    delta = +1;\n  }\n  if (delta) {\n    const target = index + delta;\n    if (target >= 0 && target < buttonArray.length) {\n      buttonArray[target].focus();\n    }\n    return;  // done\n  }\n\n  // handle u/d keys\n  if (ev.key === 'ArrowUp') {\n    delta = -1;\n  } else if (ev.key === 'ArrowDown') {\n    delta = +1;\n  } else {\n    return;\n  }\n  const previousRect = document.activeElement.getBoundingClientRect();\n  const best = {dist: Infinity, button: null};\n\n  let targetTop = undefined;\n  let candidate = index;\n  while ((candidate += delta) >= 0 && candidate < buttonArray.length) {\n    const button = buttonArray[candidate];\n    const candidateRect = button.getBoundingClientRect();\n\n    if (previousRect.top === candidateRect.top) { continue; }\n    if (targetTop === undefined) {\n      targetTop = candidateRect.top;\n    }\n    if (candidateRect.top !== targetTop) {\n      break;  // no more good candidates\n    }\n\n    const dist = Math.abs(candidateRect.left - previousRect.left);\n    if (dist < best.dist) {\n      [best.dist, best.button] = [dist, button];\n    }\n  }\n\n  if (best.button) {\n    best.button.focus();\n  } else if (targetTop === undefined && delta < 0) {\n  // if we were at top and going -ve, then return to input\n    typer.focus();\n  }\n});\n\nlet savedResults = null;\nlet query = null;\nconst show = results => {\n  savedResults = results;\n\n  chooser.textContent = '';\n  const canary = document.createElement('span');\n  chooser.appendChild(canary);\n  const updatedButtonCache = new Map();\n\n  // if there's a focus but it's not a prefix (which implies that it's text-only)\n  if (query.focus && !query.prefix) {\n    // TODO: dedup some of this code with the below generators\n    const holderFor = type => {\n      const el = document.createElement('div');\n      el.className = 'options modifier';\n\n      const buttons = document.createElement('div');\n      buttons.className = 'buttons';\n      buttons.dataset['modifier'] = type;\n      el.appendChild(buttons);\n\n      const h4 = document.createElement('h4');\n      h4.textContent = type;\n      el.appendChild(h4);\n\n      chooser.appendChild(el);\n      return buttons;\n    };\n    const createModifierButton = (holder, text, opt_value) => {\n      const button = document.createElement('button');\n      button.textContent = text;\n      if (opt_value) {\n        button.dataset['value'] = opt_value;\n      }\n      holder.appendChild(button);\n    };\n\n    const out = modifier.modify(query.focus);\n\n    if (out.gender.single || out.gender.double) {\n      const genderHolder = holderFor('gender');\n      out.gender.neutral && createModifierButton(genderHolder, '\\u{2014}');\n      out.gender.single && createModifierButton(genderHolder, '\\u{2640}', 'f');\n      out.gender.double && createModifierButton(genderHolder, '\\u{2640}\\u{2642}', 'fm');\n      out.gender.single && createModifierButton(genderHolder, '\\u{2642}', 'm');\n      out.gender.double && createModifierButton(genderHolder, '\\u{2642}\\u{2640}', 'mf');\n    }\n\n    if (out.diversity) {\n      const diversityHolder = holderFor('diversity');\n      createModifierButton(diversityHolder, '\\u{2014}');\n      for (let i = 0x1f3fb; i <= 0x1f3ff; ++i) {\n        createModifierButton(diversityHolder, String.fromCodePoint(i), i);\n      }\n    }\n  }\n\n  // create buttons and headings for all options; immediately re-add previously cached buttons\n  const replacement = document.createDocumentFragment();\n  const holders = {};\n  results && results.forEach(result => {\n    const name = result['name'];\n\n    const el = document.createElement('div');\n    el.className = 'options';\n\n    const buttons = document.createElement('div');\n    buttons.className = 'buttons';\n    buttons.dataset['word'] = name;\n    el.appendChild(buttons);\n\n    const h4 = document.createElement('h4');\n    h4.textContent = name;\n    el.appendChild(h4);\n\n    replacement.appendChild(el);\n    holders[name] = buttons;\n\n    // do a quick pass on already available buttons\n    result['pending'] = result['options'].filter(option => {\n      const button = buttonCache.get(option);\n      if (!button) {\n        return true;  // we want to redraw this later\n      } else if (!updatedButtonCache.has(option)) {\n        // don't show the same emoji button twice\n        buttons.appendChild(button);\n        updatedButtonCache.set(option, button);\n      }\n      return false;\n    });\n  });\n  buttonCache = updatedButtonCache;\n  chooser.appendChild(replacement);\n\n  // async helper function for adding emoji over multiple frames (via requestIdleCallback).\n  if (!results) { return; }\n  const p = (async function() {\n    let idle = null;\n\n    for (let i = 0, result; result = results[i]; ++i) {\n      const options = result['pending'];\n      for (let j = 0, option; option = options[j]; ++j) {\n        if (!idle || idle.timeRemaining() <= 0) {\n          const p = new Promise(resolve => window.requestIdleCallback(o => resolve(o)));\n          idle = await p;\n          if (!canary.parentNode) { return; }\n        }\n        if (!buttonCache.has(option) && modifier.isExpectedLength(option)) {\n          // TODO: If a user has allowed it, render all emojis (even invalid) anyway.\n          const holder = holders[result['name']];\n          holder.appendChild(createButton(option));\n        }\n      };\n    };\n  }());\n  p.catch(e => console.warn('couldn\\'t render emoji', e));\n};\n\n// set global callback for show\nprovider.callback(show);\n\n// handler for a prefix search\ntyper.addEventListener('query', ev => {\n  query = ev.detail;\n  provider.request(query.text, query.prefix);\n});\n\n// request an autocomplete, the user has just kept typing\ntyper.addEventListener('request', ev => {\n  const word = simplifyWord(ev.detail);\n  let choice = null;\n\n  (savedResults || []).some(result => {\n    if (result['name'] !== word) { return false; }\n    choice = result.options[0];\n    return true;\n  });\n\n  if (choice) {\n    const detail = {choice, word};\n    typer.dispatchEvent(new CustomEvent('emoji', {detail}));\n  }\n});\n","\n/**\n * @fileoverview Polyfills needed for modern browsers, even those supporting ES6 modules.\n */\n\nif (!window.requestIdleCallback) {\n  // TODO: this is a pretty terrible requestIdleCallback\n  window.requestIdleCallback = callback => {\n    const start = performance.now();\n    const fn = callback.bind(null, {\n      didTimeout: false,\n      timeRemaining: () => Math.max(0, 50 - (performance.now() - start)),\n    });\n    return window.setTimeout(fn, 1);\n  };\n\n  window.cancelIdleCallback = id => window.clearTimeout(id);\n}\n\n","\nconst all = Array.prototype.slice.call(buttons.querySelectorAll('button'));\n\nconst handler = ev => {\n  const text = (ev ? ev.detail : typer.value).trim();\n  const hasValue = Boolean(text);\n  document.body.classList.toggle('has-value', hasValue);\n  all.forEach(button => button.disabled = !hasValue);\n};\n\ntyper.addEventListener('value', handler);\nhandler();\n\n// copy handler\n(function(button, input) {\n  let timeout;\n  const defaultText = button.textContent;\n  const spaceRe = /\\s*/;\n\n  const copy = _ => {\n    const [start, end] = [input.selectionStart, input.selectionEnd];\n\n    // find start/end of content (trim, but find positions)\n    let left = 0;\n    let right = input.value.length;\n    if (input.selectionStart !== input.selectionEnd) {\n      left = input.selectionStart;\n      right = input.selectionEnd;\n    }\n    left += spaceRe.exec(input.value.substr(left))[0].length;\n    right = left + input.value.substr(left, right - left).trim().length;\n    if (right <= left) { return false; }\n\n    input.focus();\n    input.selectionStart = left;\n    input.selectionEnd = right;\n\n    let ok = false;\n    try {\n      ok = document.execCommand('copy');\n    } catch(e) {\n      console.warn('could not copy', e);\n      ok = false;\n    }\n    // restore previous selection\n    [input.selectionStart, input.selectionEnd] = [start, end];\n\n    if (!ok) { return true; }\n    console.info('copied', input.value.substr(left, right));\n\n    // show message\n    button.textContent = button.dataset.copied;\n    window.clearTimeout(timeout);\n    timeout = window.setTimeout(ev => {\n      button.textContent = defaultText;\n    }, 500);\n  };\n\n  input.addEventListener('keydown', ev => {\n    if (ev.key == 'Enter') {\n      button.click();\n      input.focus();\n    }\n  });\n  button.addEventListener('click', ev => {\n    copy();\n    button.focus();\n  });\n}(copy, typer));\n\n","\nimport * as provider from './lib/provider.js';\n\n// advanced handler\n(function(input, advanced) {\n  const form = advanced.querySelector('form');\n  const namer = form.querySelector('input');\n  const button = form.querySelector('button');\n\n  let focus = '';\n\n  input.addEventListener('query', ev => {\n    const query = ev.detail;\n    const selection = (query.text === null && query.focus !== undefined);\n    focus = query.focus;\n    advanced.hidden = !selection;\n    if (advanced.hidden) {\n      namer.value = '';\n    }\n  });\n\n  const handler = ev => {\n    button.disabled = !namer.value;\n  };\n  'input change'.split(/\\s+/).forEach(type => namer.addEventListener(type, handler));\n\n  form.addEventListener('submit', ev => {\n    ev.preventDefault();\n\n    form.classList.add('pending');\n    namer.disabled = true;\n    button.disabled = true;\n\n    const cleanup = _ => {\n      form.classList.remove('pending');\n      namer.disabled = false;\n      namer.value = '';\n      namer.dispatchEvent(new CustomEvent('change'));\n    };\n\n    const p = provider.submit(namer.value, focus).then(_ => {\n      button.classList.add('success');\n      return false;\n    }).catch(err => {\n      button.classList.add('failure');\n      console.warn('failed to submit emoji', err)\n      return true;\n    }).then(cleanup);\n\n    p.then(_ => new Promise((resolve, reject) => window.setTimeout(resolve, 2000))).then(_ => {\n      button.className = '';\n    });\n  });\n\n}(typer, advanced));\n"],"names":["isPointGender","p","isPersonGender","isFamilyMember","isVariationSelector","isDiversitySelector","isFlagPoint","unlikelyModifierBase","jsdecode","s","len","length","points","i","raw","charCodeAt","extra","push","splitEmoji","curr","point","suffix","out","check","next","modify","opt_op","stats","diversity","gender","single","double","neutral","chars","record","some","char","first","genderable","family","forEach","ch","flip","genderFlip","isSinglePerson","undefined","basicDiversity","candidate","String","fromCodePoint","isSingle","nextGenderPoint","g","previousMaster","index","master","opt_point","opt_allowOtherFlip","n","m","f","map","allowOtherFlip","genderPoint","reduce","all","concat","datasetSafeDelete","el","keys","d","dataset","key","upgrade","isWordCode","code","helper","document","createElement","className","parentNode","insertBefore","underline","appendChild","sizer","readyState","classList","add","window","addEventListener","ev","renderLine","remove","_","from","hidden","to","textContent","value","substr","left","getBoundingClientRect","width","getElementById","console","warn","style","transform","scrollLeft","setRange","initialLength","state","start","end","changeHandler","permitNextChange","selectionStart","selectionEnd","dispatchEvent","CustomEvent","detail","isAtEnd","trim","isNotWordAfter","mergedEventHandler","events","has","text","prefix","word","focus","frame","Set","dedup","clear","requestAnimationFrame","type","split","event","which","dedupRenderLine","passive","replaceFocus","call","typer","update","drift","where","arg","[object Object]","modifier.modify","emoji","choice","build","prefixLength","maxSuggestions","prefixSuggest","values","data","k","slice","part","opts","typed","rest","toLowerCase","filter","startsWith","name","options","request","performRequest","select","pendingSelect","clearTimeout","timeoutSelect","setTimeout","body","JSON","stringify","fetch","api","method","submit","FormData","append","mode","callback","requestCallback","createButton","buttonCache","get","button","set","requestIdleCallback","performance","now","fn","bind","didTimeout","timeRemaining","Math","max","cancelIdleCallback","id","Array","prototype","buttons","querySelectorAll","handler","hasValue","Boolean","toggle","disabled","input","timeout","defaultText","spaceRe","copy","right","exec","ok","execCommand","e","info","copied","click","measureText","context","getContext","font","cache","count","result","fixedWidthEmoji","emojiWidth","invalidWidth","isExpectedLength","flags","total","expectedLength","ceil","floor","c","list","Map","j","v","Error","indexed","parse","localStorage","Date","Promise","resolve","debug","then","json","local","send","localTimeout","url","encodeURIComponent","results","arr","suggest","invalidLetterRe","simplifyWord","replace","chooser","b","target","localName","provider.select","querySelector","activeElement","contains","buttonArray","indexOf","delta","previousRect","best","dist","Infinity","targetTop","candidateRect","top","abs","savedResults","query","show","canary","updatedButtonCache","holderFor","h4","createModifierButton","holder","opt_value","genderHolder","diversityHolder","replacement","createDocumentFragment","holders","option","async","idle","o","modifier.isExpectedLength","catch","provider.callback","provider.request","advanced","form","namer","selection","preventDefault","cleanup","provider.submit","err","reject"],"mappings":"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"}